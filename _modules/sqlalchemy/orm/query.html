

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sqlalchemy.orm.query &mdash; catalog  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="catalog  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> catalog
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../catalog.html">catalog package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">catalog</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>sqlalchemy.orm.query</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sqlalchemy.orm.query</h1><div class="highlight"><pre>
<span class="c"># orm/query.py</span>
<span class="c"># Copyright (C) 2005-2015 the SQLAlchemy authors and contributors</span>
<span class="c"># &lt;see AUTHORS file&gt;</span>
<span class="c">#</span>
<span class="c"># This module is part of SQLAlchemy and is released under</span>
<span class="c"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>

<span class="sd">&quot;&quot;&quot;The Query class and support.</span>

<span class="sd">Defines the :class:`.Query` class, the central</span>
<span class="sd">construct used by the ORM to construct database queries.</span>

<span class="sd">The :class:`.Query` class should not be confused with the</span>
<span class="sd">:class:`.Select` class, which defines database</span>
<span class="sd">SELECT operations at the SQL (non-ORM) level.  ``Query`` differs from</span>
<span class="sd">``Select`` in that it returns ORM-mapped objects and interacts with an</span>
<span class="sd">ORM session, whereas the ``Select`` construct interacts directly with the</span>
<span class="sd">database to return iterable result sets.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">attributes</span><span class="p">,</span> <span class="n">interfaces</span><span class="p">,</span> <span class="n">object_mapper</span><span class="p">,</span> <span class="n">persistence</span><span class="p">,</span>
    <span class="n">exc</span> <span class="k">as</span> <span class="n">orm_exc</span><span class="p">,</span> <span class="n">loading</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">_entity_descriptor</span><span class="p">,</span> <span class="n">_is_aliased_class</span><span class="p">,</span> \
    <span class="n">_is_mapped_class</span><span class="p">,</span> <span class="n">_orm_columns</span><span class="p">,</span> <span class="n">_generative</span><span class="p">,</span> <span class="n">InspectionAttr</span>
<span class="kn">from</span> <span class="nn">.path_registry</span> <span class="kn">import</span> <span class="n">PathRegistry</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AliasedClass</span><span class="p">,</span> <span class="n">ORMAdapter</span><span class="p">,</span> <span class="n">join</span> <span class="k">as</span> <span class="n">orm_join</span><span class="p">,</span> <span class="n">with_parent</span><span class="p">,</span> <span class="n">aliased</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sql</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">exc</span> <span class="k">as</span> <span class="n">sa_exc</span><span class="p">,</span> <span class="n">inspect</span><span class="p">,</span> <span class="n">inspection</span>
<span class="kn">from</span> <span class="nn">..sql.expression</span> <span class="kn">import</span> <span class="n">_interpret_as_from</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">util</span> <span class="k">as</span> <span class="n">sql_util</span><span class="p">,</span>
    <span class="n">expression</span><span class="p">,</span> <span class="n">visitors</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..sql.base</span> <span class="kn">import</span> <span class="n">ColumnCollection</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">properties</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Query&#39;</span><span class="p">,</span> <span class="s">&#39;QueryContext&#39;</span><span class="p">,</span> <span class="s">&#39;aliased&#39;</span><span class="p">]</span>


<span class="n">_path_registry</span> <span class="o">=</span> <span class="n">PathRegistry</span><span class="o">.</span><span class="n">root</span>


<span class="nd">@inspection._self_inspects</span>
<span class="nd">@log.class_logger</span>
<span class="k">class</span> <span class="nc">Query</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ORM-level SQL construction object.</span>

<span class="sd">    :class:`.Query` is the source of all SELECT statements generated by the</span>
<span class="sd">    ORM, both those formulated by end-user query operations as well as by</span>
<span class="sd">    high level internal operations such as related collection loading.  It</span>
<span class="sd">    features a generative interface whereby successive calls return a new</span>
<span class="sd">    :class:`.Query` object, a copy of the former with additional</span>
<span class="sd">    criteria and options associated with it.</span>

<span class="sd">    :class:`.Query` objects are normally initially generated using the</span>
<span class="sd">    :meth:`~.Session.query` method of :class:`.Session`.  For a full</span>
<span class="sd">    walkthrough of :class:`.Query` usage, see the</span>
<span class="sd">    :ref:`ormtutorial_toplevel`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_enable_eagerloads</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_enable_assertions</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_with_labels</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_criterion</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_yield_per</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_order_by</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_group_by</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_having</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_distinct</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_prefixes</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_suffixes</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_limit</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_for_update_arg</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_statement</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_correlate</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
    <span class="n">_populate_existing</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_invoke_all_eagers</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_version_check</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_autoflush</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_only_load_props</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_refresh_state</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_from_obj</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_join_entities</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_select_from_entity</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_mapper_adapter_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_filter_aliases</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_joinpath</span> <span class="o">=</span> <span class="n">_joinpoint</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_execution_options</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_params</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_with_options</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_with_hints</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_enable_single_crit</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_orm_only_adapt</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_orm_only_from_obj_alias</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_current_path</span> <span class="o">=</span> <span class="n">_path_registry</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">,</span> <span class="n">entity_wrapper</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">entity_wrapper</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">entity_wrapper</span> <span class="o">=</span> <span class="n">_QueryEntity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">entities</span><span class="p">):</span>
            <span class="n">entity_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entity_selectables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_entity_selectables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span> <span class="o">=</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">ent</span><span class="o">.</span><span class="n">entities</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">ext_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span> <span class="ow">and</span> \
                            <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">with_polymorphic</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">mapped_table</span> <span class="ow">not</span> <span class="ow">in</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_loads_polymorphically_with</span><span class="p">(</span>
                                <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span>
                                <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                                    <span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span>
                                    <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="n">aliased_adapter</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">elif</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
                        <span class="n">aliased_adapter</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">_adapter</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">aliased_adapter</span> <span class="o">=</span> <span class="bp">None</span>

                    <span class="n">d</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">ext_info</span><span class="p">,</span>
                        <span class="n">aliased_adapter</span>
                    <span class="p">)</span>
                <span class="n">ent</span><span class="o">.</span><span class="n">setup_entity</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="n">entity</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_mapper_loads_polymorphically_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">adapter</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_with_polymorphic_mappers</span> <span class="ow">or</span> <span class="p">[</span><span class="n">mapper</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">[</span><span class="n">m2</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m2</span><span class="o">.</span><span class="n">iterate_to_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">local_table</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span>

    <span class="k">def</span> <span class="nf">_set_select_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">set_base_alias</span><span class="p">):</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">select_from_alias</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">from_obj</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">from_obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&#39;mapper&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">is_mapper</span> <span class="ow">or</span> <span class="n">info</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="o">=</span> <span class="n">from_obj</span>
                <span class="k">if</span> <span class="n">set_base_alias</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s">&quot;A selectable (FromClause) instance is &quot;</span>
                        <span class="s">&quot;expected when the base alias is being set.&quot;</span><span class="p">)</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">selectable</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">is_selectable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s">&quot;argument is not a mapped class, mapper, &quot;</span>
                    <span class="s">&quot;aliased(), or FromClause instance.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">):</span>
                    <span class="n">from_obj</span> <span class="o">=</span> <span class="n">from_obj</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">set_base_alias</span><span class="p">:</span>
                    <span class="n">select_from_alias</span> <span class="o">=</span> <span class="n">from_obj</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_obj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">set_base_alias</span> <span class="ow">and</span> \
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">select_from_alias</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">Alias</span><span class="p">):</span>
            <span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_equivs</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">equivs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset_polymorphic_adapter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_with_polymorphic_mappers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m2</span><span class="o">.</span><span class="n">iterate_to_root</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">local_table</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_adapt_polymorphic_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&quot;parententity&quot;</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="s">&#39;parententity&#39;</span><span class="p">]</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alias</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">alias</span><span class="o">.</span><span class="n">adapt_clause</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">FromClause</span><span class="p">):</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s">&#39;table&#39;</span><span class="p">):</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alias</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alias</span><span class="o">.</span><span class="n">adapt_clause</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_adapt_col_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span>
                <span class="n">expression</span><span class="o">.</span><span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">o</span><span class="p">),</span>
                <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">cols</span>
        <span class="p">]</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_adapt_all_clauses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_adapt</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_adapt_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">,</span> <span class="n">as_filter</span><span class="p">,</span> <span class="n">orm_only</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adapt incoming clauses to transformations which</span>
<span class="sd">        have been applied within this query.&quot;&quot;&quot;</span>

        <span class="n">adapters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># do we adapt all expression elements or only those</span>
        <span class="c"># tagged as &#39;ORM&#39; constructs ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_adapt</span><span class="p">:</span>
            <span class="n">orm_only</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">as_filter</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span><span class="o">.</span><span class="n">_visitor_iterator</span><span class="p">:</span>
                <span class="n">adapters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">orm_only</span><span class="p">,</span> <span class="n">fa</span><span class="o">.</span><span class="n">replace</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="p">:</span>
            <span class="c"># for the &quot;from obj&quot; alias, apply extra rule to the</span>
            <span class="c"># &#39;ORM only&#39; check, if this query were generated from a</span>
            <span class="c"># subquery of itself, i.e. _from_selectable(), apply adaption</span>
            <span class="c"># to all SQL constructs.</span>
            <span class="n">adapters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">orm_only</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_from_obj_alias</span> <span class="k">else</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="o">.</span><span class="n">replace</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">:</span>
            <span class="n">adapters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">orm_only</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_polymorphic_element</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">adapters</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clause</span>

        <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_orm_only</span><span class="p">,</span> <span class="n">adapter</span> <span class="ow">in</span> <span class="n">adapters</span><span class="p">:</span>
                <span class="c"># if &#39;orm only&#39;, look for ORM annotations</span>
                <span class="c"># in the element before adapting.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_orm_only</span> <span class="ow">or</span> \
                        <span class="s">&#39;_orm_adapt&#39;</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span> <span class="ow">or</span> \
                        <span class="s">&quot;parententity&quot;</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>

                    <span class="n">e</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">visitors</span><span class="o">.</span><span class="n">replacement_traverse</span><span class="p">(</span>
            <span class="n">clause</span><span class="p">,</span>
            <span class="p">{},</span>
            <span class="n">replace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_mapper_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> \
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">()</span><span class="o">.</span><span class="n">entity_zero</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_mapper_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">_MapperEntity</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ent</span>

    <span class="k">def</span> <span class="nf">_joinpoint_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s">&#39;_joinpoint_entity&#39;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bind_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ezero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">ezero</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_clause_element</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">insp</span><span class="o">.</span><span class="n">mapper</span>

        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_only_mapper_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rationale</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="n">rationale</span> <span class="ow">or</span>
                <span class="s">&quot;This operation requires a Query &quot;</span>
                <span class="s">&quot;against a single mapper.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_only_full_mapper_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">!=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;</span><span class="si">%s</span><span class="s">() can only be used against &quot;</span>
                <span class="s">&quot;a single mapped class.&quot;</span> <span class="o">%</span> <span class="n">methname</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span><span class="o">.</span><span class="n">entity_zero</span>

    <span class="k">def</span> <span class="nf">_only_entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rationale</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="n">rationale</span> <span class="ow">or</span>
                <span class="s">&quot;This operation requires a Query &quot;</span>
                <span class="s">&quot;against a single mapper.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_zero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__all_equivs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">equivs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_entities</span><span class="p">:</span>
            <span class="n">equivs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">equivs</span>

    <span class="k">def</span> <span class="nf">_get_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_condition</span><span class="p">(</span>
            <span class="s">&quot;get&quot;</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_existing_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_assertion</span><span class="p">(</span><span class="s">&quot;get&quot;</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_criterion_assertion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">or</span> <span class="p">(</span><span class="n">order_by</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">distinct</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Query.</span><span class="si">%s</span><span class="s">() being called on a &quot;</span>
                <span class="s">&quot;Query with existing criterion. &quot;</span> <span class="o">%</span> <span class="n">meth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_criterion_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_assertion</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">order_by</span><span class="p">,</span> <span class="n">distinct</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_no_clauseelement_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Query.</span><span class="si">%s</span><span class="s">() being called on a &quot;</span>
                <span class="s">&quot;Query with existing criterion. &quot;</span> <span class="o">%</span> <span class="n">meth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_criterion_condition</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_statement_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="p">(</span><span class="s">&quot;Query.</span><span class="si">%s</span><span class="s">() being called on a Query with an existing full &quot;</span>
                 <span class="s">&quot;statement - can&#39;t apply criterion.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">meth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_no_limit_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Query.</span><span class="si">%s</span><span class="s">() being called on a Query which already has LIMIT &quot;</span>
                <span class="s">&quot;or OFFSET applied. To modify the row-limited results of a &quot;</span>
                <span class="s">&quot; Query, call from_self() first.  &quot;</span>
                <span class="s">&quot;Otherwise, call </span><span class="si">%s</span><span class="s">() before limit() or offset() &quot;</span>
                <span class="s">&quot;are applied.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">populate_existing</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">version_check</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">only_load_props</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">refresh_state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">populate_existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span> <span class="o">=</span> <span class="n">populate_existing</span>
        <span class="k">if</span> <span class="n">version_check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_version_check</span> <span class="o">=</span> <span class="n">version_check</span>
        <span class="k">if</span> <span class="n">refresh_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_state</span> <span class="o">=</span> <span class="n">refresh_state</span>
        <span class="k">if</span> <span class="n">only_load_props</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_only_load_props</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">only_load_props</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">statement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The full SELECT statement represented by this Query.</span>

<span class="sd">        The statement by default will not have disambiguating labels</span>
<span class="sd">        applied to the construct unless with_labels(True) is called</span>
<span class="sd">        first.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_context</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_with_labels</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">statement</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>

        <span class="c"># TODO: there&#39;s no tests covering effects of</span>
        <span class="c"># the annotation not being there</span>
        <span class="k">return</span> <span class="n">stmt</span><span class="o">.</span><span class="n">_annotate</span><span class="p">({</span><span class="s">&#39;no_replacement_traverse&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">subquery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">reduce_columns</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the full SELECT statement represented by</span>
<span class="sd">        this :class:`.Query`, embedded within an :class:`.Alias`.</span>

<span class="sd">        Eager JOIN generation within the query is disabled.</span>

<span class="sd">        :param name: string name to be assigned as the alias;</span>
<span class="sd">            this is passed through to :meth:`.FromClause.alias`.</span>
<span class="sd">            If ``None``, a name will be deterministically generated</span>
<span class="sd">            at compile time.</span>

<span class="sd">        :param with_labels: if True, :meth:`.with_labels` will be called</span>
<span class="sd">         on the :class:`.Query` first to apply table-qualified labels</span>
<span class="sd">         to all columns.</span>

<span class="sd">        :param reduce_columns: if True, :meth:`.Select.reduce_columns` will</span>
<span class="sd">         be called on the resulting :func:`.select` construct,</span>
<span class="sd">         to remove same-named columns where one also refers to the other</span>
<span class="sd">         via foreign key or WHERE clause equivalence.</span>

<span class="sd">         .. versionchanged:: 0.8 the ``with_labels`` and ``reduce_columns``</span>
<span class="sd">            keyword arguments were added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_labels</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">statement</span>
        <span class="k">if</span> <span class="n">reduce_columns</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">reduce_columns</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cte</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full SELECT statement represented by this</span>
<span class="sd">        :class:`.Query` represented as a common table expression (CTE).</span>

<span class="sd">        .. versionadded:: 0.7.6</span>

<span class="sd">        Parameters and usage are the same as those of the</span>
<span class="sd">        :meth:`.SelectBase.cte` method; see that method for</span>
<span class="sd">        further details.</span>

<span class="sd">        Here is the `Postgresql WITH</span>
<span class="sd">        RECURSIVE example</span>
<span class="sd">        &lt;http://www.postgresql.org/docs/8.4/static/queries-with.html&gt;`_.</span>
<span class="sd">        Note that, in this example, the ``included_parts`` cte and the</span>
<span class="sd">        ``incl_alias`` alias of it are Core selectables, which</span>
<span class="sd">        means the columns are accessed via the ``.c.`` attribute.  The</span>
<span class="sd">        ``parts_alias`` object is an :func:`.orm.aliased` instance of the</span>
<span class="sd">        ``Part`` entity, so column-mapped attributes are available</span>
<span class="sd">        directly::</span>

<span class="sd">            from sqlalchemy.orm import aliased</span>

<span class="sd">            class Part(Base):</span>
<span class="sd">                __tablename__ = &#39;part&#39;</span>
<span class="sd">                part = Column(String, primary_key=True)</span>
<span class="sd">                sub_part = Column(String, primary_key=True)</span>
<span class="sd">                quantity = Column(Integer)</span>

<span class="sd">            included_parts = session.query(</span>
<span class="sd">                            Part.sub_part,</span>
<span class="sd">                            Part.part,</span>
<span class="sd">                            Part.quantity).\\</span>
<span class="sd">                                filter(Part.part==&quot;our part&quot;).\\</span>
<span class="sd">                                cte(name=&quot;included_parts&quot;, recursive=True)</span>

<span class="sd">            incl_alias = aliased(included_parts, name=&quot;pr&quot;)</span>
<span class="sd">            parts_alias = aliased(Part, name=&quot;p&quot;)</span>
<span class="sd">            included_parts = included_parts.union_all(</span>
<span class="sd">                session.query(</span>
<span class="sd">                    parts_alias.sub_part,</span>
<span class="sd">                    parts_alias.part,</span>
<span class="sd">                    parts_alias.quantity).\\</span>
<span class="sd">                        filter(parts_alias.part==incl_alias.c.sub_part)</span>
<span class="sd">                )</span>

<span class="sd">            q = session.query(</span>
<span class="sd">                    included_parts.c.sub_part,</span>
<span class="sd">                    func.sum(included_parts.c.quantity).</span>
<span class="sd">                        label(&#39;total_quantity&#39;)</span>
<span class="sd">                ).\\</span>
<span class="sd">                group_by(included_parts.c.sub_part)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.SelectBase.cte`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">statement</span><span class="o">.</span><span class="n">cte</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full SELECT statement represented by this</span>
<span class="sd">        :class:`.Query`, converted</span>
<span class="sd">        to a scalar subquery with a label of the given name.</span>

<span class="sd">        Analogous to :meth:`sqlalchemy.sql.expression.SelectBase.label`.</span>

<span class="sd">        .. versionadded:: 0.6.5</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full SELECT statement represented by this</span>
<span class="sd">        :class:`.Query`, converted to a scalar subquery.</span>

<span class="sd">        Analogous to :meth:`sqlalchemy.sql.expression.SelectBase.as_scalar`.</span>

<span class="sd">        .. versionadded:: 0.6.5</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the :class:`.Select` object emitted by this :class:`.Query`.</span>

<span class="sd">        Used for :func:`.inspect` compatibility, this is equivalent to::</span>

<span class="sd">            query.enable_eagerloads(False).with_labels().statement</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__clause_element__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span><span class="o">.</span><span class="n">statement</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">enable_eagerloads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Control whether or not eager joins and subqueries are</span>
<span class="sd">        rendered.</span>

<span class="sd">        When set to False, the returned Query will not render</span>
<span class="sd">        eager joins regardless of :func:`~sqlalchemy.orm.joinedload`,</span>
<span class="sd">        :func:`~sqlalchemy.orm.subqueryload` options</span>
<span class="sd">        or mapper-level ``lazy=&#39;joined&#39;``/``lazy=&#39;subquery&#39;``</span>
<span class="sd">        configurations.</span>

<span class="sd">        This is used primarily when nesting the Query&#39;s</span>
<span class="sd">        statement into a subquery or other</span>
<span class="sd">        selectable, or when using :meth:`.Query.yield_per`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_eagerloads</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_no_yield_per</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
            <span class="s">&quot;The yield_per Query option is currently not &quot;</span>
            <span class="s">&quot;compatible with </span><span class="si">%s</span><span class="s"> eager loading.  Please &quot;</span>
            <span class="s">&quot;specify lazyload(&#39;*&#39;) or query.enable_eagerloads(False) in &quot;</span>
            <span class="s">&quot;order to &quot;</span>
            <span class="s">&quot;proceed with query.yield_per().&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply column labels to the return value of Query.statement.</span>

<span class="sd">        Indicates that this Query&#39;s `statement` accessor should return</span>
<span class="sd">        a SELECT statement that applies labels to all columns in the</span>
<span class="sd">        form &lt;tablename&gt;_&lt;columnname&gt;; this is commonly used to</span>
<span class="sd">        disambiguate columns from multiple tables which have the same</span>
<span class="sd">        name.</span>

<span class="sd">        When the `Query` actually issues SQL to load rows, it always</span>
<span class="sd">        uses column labeling.</span>

<span class="sd">        .. note:: The :meth:`.Query.with_labels` method *only* applies</span>
<span class="sd">           the output of :attr:`.Query.statement`, and *not* to any of</span>
<span class="sd">           the result-row invoking systems of :class:`.Query` itself, e.g.</span>
<span class="sd">           :meth:`.Query.first`, :meth:`.Query.all`, etc.   To execute</span>
<span class="sd">           a query using :meth:`.Query.with_labels`, invoke the</span>
<span class="sd">           :attr:`.Query.statement` using :meth:`.Session.execute`::</span>

<span class="sd">                result = session.execute(query.with_labels().statement)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_labels</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">enable_assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Control whether assertions are generated.</span>

<span class="sd">        When set to False, the returned Query will</span>
<span class="sd">        not assert its state before certain operations,</span>
<span class="sd">        including that LIMIT/OFFSET has not been applied</span>
<span class="sd">        when filter() is called, no criterion exists</span>
<span class="sd">        when get() is called, and no &quot;from_statement()&quot;</span>
<span class="sd">        exists when filter()/order_by()/group_by() etc.</span>
<span class="sd">        is called.  This more permissive mode is used by</span>
<span class="sd">        custom Query subclasses to specify criterion or</span>
<span class="sd">        other modifiers outside of the usual usage patterns.</span>

<span class="sd">        Care should be taken to ensure that the usage</span>
<span class="sd">        pattern is even possible.  A statement applied</span>
<span class="sd">        by from_statement() will override any criterion</span>
<span class="sd">        set by filter() or order_by(), for example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_assertions</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">whereclause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A readonly attribute which returns the current WHERE criterion for</span>
<span class="sd">        this Query.</span>

<span class="sd">        This returned value is a SQL expression construct, or ``None`` if no</span>
<span class="sd">        criterion has been established.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_with_current_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;indicate that this query applies to objects loaded</span>
<span class="sd">        within a certain path.</span>

<span class="sd">        Used by deferred loaders (see strategies.py) which transfer</span>
<span class="sd">        query options from an originating query to a newly generated</span>
<span class="sd">        query intended for the deferred load.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">with_polymorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">cls_or_mappers</span><span class="p">,</span>
                         <span class="n">selectable</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">polymorphic_on</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load columns for inheriting classes.</span>

<span class="sd">        :meth:`.Query.with_polymorphic` applies transformations</span>
<span class="sd">        to the &quot;main&quot; mapped class represented by this :class:`.Query`.</span>
<span class="sd">        The &quot;main&quot; mapped class here means the :class:`.Query`</span>
<span class="sd">        object&#39;s first argument is a full class, i.e.</span>
<span class="sd">        ``session.query(SomeClass)``. These transformations allow additional</span>
<span class="sd">        tables to be present in the FROM clause so that columns for a</span>
<span class="sd">        joined-inheritance subclass are available in the query, both for the</span>
<span class="sd">        purposes of load-time efficiency as well as the ability to use</span>
<span class="sd">        these columns at query time.</span>

<span class="sd">        See the documentation section :ref:`with_polymorphic` for</span>
<span class="sd">        details on how this method is used.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">            A new and more flexible function</span>
<span class="sd">            :func:`.orm.with_polymorphic` supersedes</span>
<span class="sd">            :meth:`.Query.with_polymorphic`, as it can apply the equivalent</span>
<span class="sd">            functionality to any set of columns or classes in the</span>
<span class="sd">            :class:`.Query`, not just the &quot;zero mapper&quot;.  See that</span>
<span class="sd">            function for a description of arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_primary_entity</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;No primary mapper set up for this Query.&quot;</span><span class="p">)</span>
        <span class="n">entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">entity</span><span class="o">.</span><span class="n">set_with_polymorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">cls_or_mappers</span><span class="p">,</span>
                                    <span class="n">selectable</span><span class="o">=</span><span class="n">selectable</span><span class="p">,</span>
                                    <span class="n">polymorphic_on</span><span class="o">=</span><span class="n">polymorphic_on</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">yield_per</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield only ``count`` rows at a time.</span>

<span class="sd">        The purpose of this method is when fetching very large result sets</span>
<span class="sd">        (&gt; 10K rows), to batch results in sub-collections and yield them</span>
<span class="sd">        out partially, so that the Python interpreter doesn&#39;t need to declare</span>
<span class="sd">        very large areas of memory which is both time consuming and leads</span>
<span class="sd">        to excessive memory use.   The performance from fetching hundreds of</span>
<span class="sd">        thousands of rows can often double when a suitable yield-per setting</span>
<span class="sd">        (e.g. approximately 1000) is used, even with DBAPIs that buffer</span>
<span class="sd">        rows (which are most).</span>

<span class="sd">        The :meth:`.Query.yield_per` method **is not compatible with most</span>
<span class="sd">        eager loading schemes, including subqueryload and joinedload with</span>
<span class="sd">        collections**.  For this reason, it may be helpful to disable</span>
<span class="sd">        eager loads, either unconditionally with</span>
<span class="sd">        :meth:`.Query.enable_eagerloads`::</span>

<span class="sd">            q = sess.query(Object).yield_per(100).enable_eagerloads(False)</span>

<span class="sd">        Or more selectively using :func:`.lazyload`; such as with</span>
<span class="sd">        an asterisk to specify the default loader scheme::</span>

<span class="sd">            q = sess.query(Object).yield_per(100).\\</span>
<span class="sd">                options(lazyload(&#39;*&#39;), joinedload(Object.some_related))</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Use this method with caution; if the same instance is</span>
<span class="sd">            present in more than one batch of rows, end-user changes</span>
<span class="sd">            to attributes will be overwritten.</span>

<span class="sd">            In particular, it&#39;s usually impossible to use this setting</span>
<span class="sd">            with eagerly loaded collections (i.e. any lazy=&#39;joined&#39; or</span>
<span class="sd">            &#39;subquery&#39;) since those collections will be cleared for a</span>
<span class="sd">            new load when encountered in a subsequent result batch.</span>
<span class="sd">            In the case of &#39;subquery&#39; loading, the full result for all</span>
<span class="sd">            rows is fetched which generally defeats the purpose of</span>
<span class="sd">            :meth:`~sqlalchemy.orm.query.Query.yield_per`.</span>

<span class="sd">            Also note that while</span>
<span class="sd">            :meth:`~sqlalchemy.orm.query.Query.yield_per` will set the</span>
<span class="sd">            ``stream_results`` execution option to True, currently</span>
<span class="sd">            this is only understood by</span>
<span class="sd">            :mod:`~sqlalchemy.dialects.postgresql.psycopg2` dialect</span>
<span class="sd">            which will stream results using server side cursors</span>
<span class="sd">            instead of pre-buffer all rows for this query. Other</span>
<span class="sd">            DBAPIs **pre-buffer all rows** before making them</span>
<span class="sd">            available.  The memory use of raw database rows is much less</span>
<span class="sd">            than that of an ORM-mapped object, but should still be taken into</span>
<span class="sd">            consideration when benchmarking.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.enable_eagerloads`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_yield_per</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="p">{</span><span class="s">&quot;stream_results&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
             <span class="s">&quot;max_row_buffer&quot;</span><span class="p">:</span> <span class="n">count</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an instance based on the given primary key identifier,</span>
<span class="sd">        or ``None`` if not found.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            my_user = session.query(User).get(5)</span>

<span class="sd">            some_object = session.query(VersionedFoo).get((5, 10))</span>

<span class="sd">        :meth:`~.Query.get` is special in that it provides direct</span>
<span class="sd">        access to the identity map of the owning :class:`.Session`.</span>
<span class="sd">        If the given primary key identifier is present</span>
<span class="sd">        in the local identity map, the object is returned</span>
<span class="sd">        directly from this collection and no SQL is emitted,</span>
<span class="sd">        unless the object has been marked fully expired.</span>
<span class="sd">        If not present,</span>
<span class="sd">        a SELECT is performed in order to locate the object.</span>

<span class="sd">        :meth:`~.Query.get` also will perform a check if</span>
<span class="sd">        the object is present in the identity map and</span>
<span class="sd">        marked as expired - a SELECT</span>
<span class="sd">        is emitted to refresh the object as well as to</span>
<span class="sd">        ensure that the row is still present.</span>
<span class="sd">        If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.</span>

<span class="sd">        :meth:`~.Query.get` is only used to return a single</span>
<span class="sd">        mapped instance, not multiple instances or</span>
<span class="sd">        individual column constructs, and strictly</span>
<span class="sd">        on a single primary key value.  The originating</span>
<span class="sd">        :class:`.Query` must be constructed in this way,</span>
<span class="sd">        i.e. against a single mapped entity,</span>
<span class="sd">        with no additional filtering criterion.  Loading</span>
<span class="sd">        options via :meth:`~.Query.options` may be applied</span>
<span class="sd">        however, and will be used if the object is not</span>
<span class="sd">        yet locally present.</span>

<span class="sd">        A lazy-loading, many-to-one attribute configured</span>
<span class="sd">        by :func:`.relationship`, using a simple</span>
<span class="sd">        foreign-key-to-primary-key criterion, will also use an</span>
<span class="sd">        operation equivalent to :meth:`~.Query.get` in order to retrieve</span>
<span class="sd">        the target value from the local identity map</span>
<span class="sd">        before querying the database.  See :doc:`/orm/loading_relationships`</span>
<span class="sd">        for further details on relationship loading.</span>

<span class="sd">        :param ident: A scalar or tuple value representing</span>
<span class="sd">         the primary key.   For a composite primary key,</span>
<span class="sd">         the order of identifiers corresponds in most cases</span>
<span class="sd">         to that of the mapped :class:`.Table` object&#39;s</span>
<span class="sd">         primary key columns.  For a :func:`.mapper` that</span>
<span class="sd">         was given the ``primary key`` argument during</span>
<span class="sd">         construction, the order of identifiers corresponds</span>
<span class="sd">         to the elements present in this collection.</span>

<span class="sd">        :return: The object instance, or ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_impl</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">loading</span><span class="o">.</span><span class="n">load_on_ident</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">fallback_fn</span><span class="p">):</span>
        <span class="c"># convert composite types to individual args</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="s">&#39;__composite_values__&#39;</span><span class="p">):</span>
            <span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span><span class="o">.</span><span class="n">__composite_values__</span><span class="p">()</span>

        <span class="n">ident</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_full_mapper_zero</span><span class="p">(</span><span class="s">&quot;get&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Incorrect number of values in identifier to formulate &quot;</span>
                <span class="s">&quot;primary key for query.get(); primary key columns are </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">))</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">identity_key_from_primary_key</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">always_refresh</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

            <span class="n">instance</span> <span class="o">=</span> <span class="n">loading</span><span class="o">.</span><span class="n">get_from_identity</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_OFF</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_existing_condition</span><span class="p">()</span>
                <span class="c"># reject calls for id in identity map but class</span>
                <span class="c"># mismatch.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="n">instance</span>

        <span class="k">return</span> <span class="n">fallback_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Query` construct which will correlate the given</span>
<span class="sd">        FROM clauses to that of an enclosing :class:`.Query` or</span>
<span class="sd">        :func:`~.expression.select`.</span>

<span class="sd">        The method here accepts mapped classes, :func:`.aliased` constructs,</span>
<span class="sd">        and :func:`.mapper` constructs as arguments, which are resolved into</span>
<span class="sd">        expression constructs, in addition to appropriate expression</span>
<span class="sd">        constructs.</span>

<span class="sd">        The correlation arguments are ultimately passed to</span>
<span class="sd">        :meth:`.Select.correlate` after coercion to expression constructs.</span>

<span class="sd">        The correlation arguments take effect in such cases</span>
<span class="sd">        as when :meth:`.Query.from_self` is used, or when</span>
<span class="sd">        a subquery as returned by :meth:`.Query.subquery` is</span>
<span class="sd">        embedded in another :func:`~.expression.select` construct.</span>

<span class="sd">         &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">_interpret_as_from</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setting</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a Query with a specific &#39;autoflush&#39; setting.</span>

<span class="sd">        Note that a Session with autoflush=False will</span>
<span class="sd">        not autoflush, even if this flag is set to True at the</span>
<span class="sd">        Query level.  Therefore this flag is usually used only</span>
<span class="sd">        to disable autoflush for a specific Query.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span> <span class="o">=</span> <span class="n">setting</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">populate_existing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Query` that will expire and refresh all instances</span>
<span class="sd">        as they are loaded, or reused from the current :class:`.Session`.</span>

<span class="sd">        :meth:`.populate_existing` does not improve behavior when</span>
<span class="sd">        the ORM is used normally - the :class:`.Session` object&#39;s usual</span>
<span class="sd">        behavior of maintaining a transaction and expiring all attributes</span>
<span class="sd">        after rollback or commit handles object state automatically.</span>
<span class="sd">        This method is not intended for general use.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_with_invoke_all_eagers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the &#39;invoke all eagers&#39; flag which causes joined- and</span>
<span class="sd">        subquery loaders to traverse into already-loaded related objects</span>
<span class="sd">        and collections.</span>

<span class="sd">        Default is that of :attr:`.Query._invoke_all_eagers`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invoke_all_eagers</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">with_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add filtering criterion that relates the given instance</span>
<span class="sd">        to a child object or collection, using its attribute state</span>
<span class="sd">        as well as an established :func:`.relationship()`</span>
<span class="sd">        configuration.</span>

<span class="sd">        The method uses the :func:`.with_parent` function to generate</span>
<span class="sd">        the clause, the result of which is passed to :meth:`.Query.filter`.</span>

<span class="sd">        Parameters are the same as :func:`.with_parent`, with the exception</span>
<span class="sd">        that the given property can be None, in which case a search is</span>
<span class="sd">        performed against this :class:`.Query` object&#39;s target mapper.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">property</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">iterate_properties</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">properties</span><span class="o">.</span><span class="n">RelationshipProperty</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">prop</span><span class="o">.</span><span class="n">mapper</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">():</span>
                    <span class="nb">property</span> <span class="o">=</span> <span class="n">prop</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s">&quot;Could not locate a property which relates instances &quot;</span>
                    <span class="s">&quot;of class &#39;</span><span class="si">%s</span><span class="s">&#39; to instances of class &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                        <span class="n">instance</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">with_parent</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">property</span><span class="p">))</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">add_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add a mapped entity to the list of result columns</span>
<span class="sd">        to be returned.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_MapperEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entity_selectables</span><span class="p">([</span><span class="n">m</span><span class="p">])</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Query` that will use the given :class:`.Session`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>

    <span class="k">def</span> <span class="nf">from_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a Query that selects from this Query&#39;s</span>
<span class="sd">        SELECT statement.</span>

<span class="sd">        \*entities - optional list of entities which will replace</span>
<span class="sd">        those being selected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fromclause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">statement</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span><span class="n">fromclause</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_enable_single_crit</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_select_from_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">entities</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">q</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_set_enable_single_crit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_single_crit</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_from_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromclause</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s">&#39;_statement&#39;</span><span class="p">,</span> <span class="s">&#39;_criterion&#39;</span><span class="p">,</span>
                <span class="s">&#39;_order_by&#39;</span><span class="p">,</span> <span class="s">&#39;_group_by&#39;</span><span class="p">,</span>
                <span class="s">&#39;_limit&#39;</span><span class="p">,</span> <span class="s">&#39;_offset&#39;</span><span class="p">,</span>
                <span class="s">&#39;_joinpath&#39;</span><span class="p">,</span> <span class="s">&#39;_joinpoint&#39;</span><span class="p">,</span>
                <span class="s">&#39;_distinct&#39;</span><span class="p">,</span> <span class="s">&#39;_having&#39;</span><span class="p">,</span>
                <span class="s">&#39;_prefixes&#39;</span><span class="p">,</span> <span class="s">&#39;_suffixes&#39;</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_select_from</span><span class="p">([</span><span class="n">fromclause</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c"># this enables clause adaptation for non-ORM</span>
        <span class="c"># expressions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orm_only_from_obj_alias</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">old_entities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">old_entities</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator yielding result tuples corresponding</span>
<span class="sd">        to the given list of columns&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">entity_wrapper</span><span class="o">=</span><span class="n">_ColumnEntity</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">_yield_per</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">_yield_per</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a scalar result corresponding to the given</span>
<span class="sd">        column expression.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">column</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Query` replacing the SELECT list with the</span>
<span class="sd">        given entities.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            # Users, filtered on some arbitrary criterion</span>
<span class="sd">            # and then ordered by related email address</span>
<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                        join(User.address).\\</span>
<span class="sd">                        filter(User.name.like(&#39;%ed%&#39;)).\\</span>
<span class="sd">                        order_by(Address.email)</span>

<span class="sd">            # given *only* User.id==5, Address.email, and &#39;q&#39;, what</span>
<span class="sd">            # would the *next* User in the result be ?</span>
<span class="sd">            subq = q.with_entities(Address.email).\\</span>
<span class="sd">                        order_by(None).\\</span>
<span class="sd">                        filter(User.id==5).\\</span>
<span class="sd">                        subquery()</span>
<span class="sd">            q = q.join((subq, subq.c.email &lt; Address.email)).\\</span>
<span class="sd">                        limit(1)</span>

<span class="sd">        .. versionadded:: 0.6.5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entities</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one or more column expressions to the list</span>
<span class="sd">        of result columns to be returned.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column</span><span class="p">:</span>
            <span class="n">_ColumnEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="c"># _ColumnEntity may add many entities if the</span>
        <span class="c"># given arg is a FROM clause</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_entity_selectables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="n">l</span><span class="p">:])</span>

    <span class="nd">@util.pending_deprecation</span><span class="p">(</span><span class="s">&quot;0.7&quot;</span><span class="p">,</span>
                              <span class="s">&quot;:meth:`.add_column` is superseded &quot;</span>
                              <span class="s">&quot;by :meth:`.add_columns`&quot;</span><span class="p">,</span>
                              <span class="bp">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a column expression to the list of result columns to be</span>
<span class="sd">        returned.</span>

<span class="sd">        Pending deprecation: :meth:`.add_column` will be superseded by</span>
<span class="sd">        :meth:`.add_columns`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new Query object, applying the given list of</span>
<span class="sd">        mapper options.</span>

<span class="sd">        Most supplied options regard changing how column- and</span>
<span class="sd">        relationship-mapped attributes are loaded. See the sections</span>
<span class="sd">        :ref:`deferred` and :doc:`/orm/loading_relationships` for reference</span>
<span class="sd">        documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conditional_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditional</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># most MapperOptions write to the &#39;_attributes&#39; dictionary,</span>
        <span class="c"># so copy that as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">flatten_iterator</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_options</span> <span class="o">+</span> <span class="n">opts</span>
        <span class="k">if</span> <span class="n">conditional</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">process_query_conditionally</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">process_query</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Query` object transformed by</span>
<span class="sd">        the given function.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            def filter_something(criterion):</span>
<span class="sd">                def transform(q):</span>
<span class="sd">                    return q.filter(criterion)</span>
<span class="sd">                return transform</span>

<span class="sd">            q = q.with_transformation(filter_something(x==5))</span>

<span class="sd">        This allows ad-hoc recipes to be created for :class:`.Query`</span>
<span class="sd">        objects.  See the example at :ref:`hybrid_transformers`.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="o">=</span><span class="s">&#39;*&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an indexing or other executional context</span>
<span class="sd">        hint for the given entity or selectable to</span>
<span class="sd">        this :class:`.Query`.</span>

<span class="sd">        Functionality is passed straight through to</span>
<span class="sd">        :meth:`~sqlalchemy.sql.expression.Select.with_hint`,</span>
<span class="sd">        with the addition that ``selectable`` can be a</span>
<span class="sd">        :class:`.Table`, :class:`.Alias`, or ORM entity / mapped class</span>
<span class="sd">        /etc.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.with_statement_hint`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">selectable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">selectable</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">selectable</span><span class="p">)</span><span class="o">.</span><span class="n">selectable</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_with_hints</span> <span class="o">+=</span> <span class="p">((</span><span class="n">selectable</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">with_statement_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="o">=</span><span class="s">&#39;*&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add a statement hint to this :class:`.Select`.</span>

<span class="sd">        This method is similar to :meth:`.Select.with_hint` except that</span>
<span class="sd">        it does not require an individual table, and instead applies to the</span>
<span class="sd">        statement as a whole.</span>

<span class="sd">        This feature calls down into :meth:`.Select.with_statement_hint`.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.with_hint`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">dialect_name</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set non-SQL options which take effect during execution.</span>

<span class="sd">        The options are the same as those accepted by</span>
<span class="sd">        :meth:`.Connection.execution_options`.</span>

<span class="sd">        Note that the ``stream_results`` execution option is enabled</span>
<span class="sd">        automatically if the :meth:`~sqlalchemy.orm.query.Query.yield_per()`</span>
<span class="sd">        method is used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_lockmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Query` object with the specified &quot;locking mode&quot;,</span>
<span class="sd">        which essentially refers to the ``FOR UPDATE`` clause.</span>

<span class="sd">        .. deprecated:: 0.9.0 superseded by :meth:`.Query.with_for_update`.</span>

<span class="sd">        :param mode: a string representing the desired locking mode.</span>
<span class="sd">         Valid values are:</span>

<span class="sd">         * ``None`` - translates to no lockmode</span>

<span class="sd">         * ``&#39;update&#39;`` - translates to ``FOR UPDATE``</span>
<span class="sd">           (standard SQL, supported by most dialects)</span>

<span class="sd">         * ``&#39;update_nowait&#39;`` - translates to ``FOR UPDATE NOWAIT``</span>
<span class="sd">           (supported by Oracle, PostgreSQL 8.1 upwards)</span>

<span class="sd">         * ``&#39;read&#39;`` - translates to ``LOCK IN SHARE MODE`` (for MySQL),</span>
<span class="sd">           and ``FOR SHARE`` (for PostgreSQL)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.with_for_update` - improved API for</span>
<span class="sd">            specifying the ``FOR UPDATE`` clause.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">LockmodeArg</span><span class="o">.</span><span class="n">parse_legacy_query</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">with_for_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new :class:`.Query` with the specified options for the</span>
<span class="sd">        ``FOR UPDATE`` clause.</span>

<span class="sd">        The behavior of this method is identical to that of</span>
<span class="sd">        :meth:`.SelectBase.with_for_update`.  When called with no arguments,</span>
<span class="sd">        the resulting ``SELECT`` statement will have a ``FOR UPDATE`` clause</span>
<span class="sd">        appended.  When additional arguments are specified, backend-specific</span>
<span class="sd">        options such as ``FOR UPDATE NOWAIT`` or ``LOCK IN SHARE MODE``</span>
<span class="sd">        can take effect.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            q = sess.query(User).with_for_update(nowait=True, of=User)</span>

<span class="sd">        The above query on a Postgresql backend will render like::</span>

<span class="sd">            SELECT users.id AS users_id FROM users FOR UPDATE OF users NOWAIT</span>

<span class="sd">        .. versionadded:: 0.9.0 :meth:`.Query.with_for_update` supersedes</span>
<span class="sd">           the :meth:`.Query.with_lockmode` method.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.GenerativeSelect.with_for_update` - Core level method with</span>
<span class="sd">            full argument and behavioral description.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">LockmodeArg</span><span class="p">(</span><span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="n">nowait</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="n">of</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add values for bind parameters which may have been</span>
<span class="sd">        specified in filter().</span>

<span class="sd">        parameters may be specified using \**kwargs, or optionally a single</span>
<span class="sd">        dictionary as the first positional argument. The reason for both is</span>
<span class="sd">        that \**kwargs is convenient, however some parameter dictionaries</span>
<span class="sd">        contain unicode keys in which case \**kwargs cannot be used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s">&quot;params() takes zero or one positional argument, &quot;</span>
                <span class="s">&quot;which is a dictionary.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;apply the given filtering criterion to a copy</span>
<span class="sd">        of this :class:`.Query`, using SQL expressions.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            session.query(MyClass).filter(MyClass.name == &#39;some name&#39;)</span>

<span class="sd">        Multiple criteria may be specified as comma separated; the effect</span>
<span class="sd">        is that they will be joined together using the :func:`.and_`</span>
<span class="sd">        function::</span>

<span class="sd">            session.query(MyClass).\\</span>
<span class="sd">                filter(MyClass.name == &#39;some name&#39;, MyClass.id &gt; 5)</span>

<span class="sd">        The criterion is any SQL expression object applicable to the</span>
<span class="sd">        WHERE clause of a select.   String expressions are coerced</span>
<span class="sd">        into SQL expression constructs via the :func:`.text` construct.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.filter_by` - filter on keyword expressions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">criterion</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

            <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">&amp;</span> <span class="n">criterion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_criterion</span> <span class="o">=</span> <span class="n">criterion</span>

    <span class="k">def</span> <span class="nf">filter_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;apply the given filtering criterion to a copy</span>
<span class="sd">        of this :class:`.Query`, using keyword expressions.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            session.query(MyClass).filter_by(name = &#39;some name&#39;)</span>

<span class="sd">        Multiple criteria may be specified as comma separated; the effect</span>
<span class="sd">        is that they will be joined together using the :func:`.and_`</span>
<span class="sd">        function::</span>

<span class="sd">            session.query(MyClass).\\</span>
<span class="sd">                filter_by(name = &#39;some name&#39;, id = 5)</span>

<span class="sd">        The keyword expressions are extracted from the primary</span>
<span class="sd">        entity of the query, or the last entity that was the</span>
<span class="sd">        target of a call to :meth:`.Query.join`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.filter` - filter on SQL expressions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">_entity_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">(),</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span>
                   <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">sql</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">))</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;apply one or more ORDER BY criterion to the query and return</span>
<span class="sd">        the newly resulting ``Query``</span>

<span class="sd">        All existing ORDER BY settings can be suppressed by</span>
<span class="sd">        passing ``None`` - this will suppress any ORDER BY configured</span>
<span class="sd">        on mappers as well.</span>

<span class="sd">        Alternatively, an existing ORDER BY setting on the Query</span>
<span class="sd">        object can be entirely cancelled by passing ``False``</span>
<span class="sd">        as the value - use this before calling methods where</span>
<span class="sd">        an ORDER BY is invalid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&#39;_order_by&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">return</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_col_list</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">+</span> <span class="n">criterion</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;apply one or more GROUP BY criterion to the query and return</span>
<span class="sd">        the newly resulting :class:`.Query`&quot;&quot;&quot;</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_orm_columns</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">criterion</span><span class="p">]))</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_col_list</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">+</span> <span class="n">criterion</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;apply a HAVING criterion to the query and return the</span>
<span class="sd">        newly resulting :class:`.Query`.</span>

<span class="sd">        :meth:`~.Query.having` is used in conjunction with</span>
<span class="sd">        :meth:`~.Query.group_by`.</span>

<span class="sd">        HAVING criterion makes it possible to use filters on aggregate</span>
<span class="sd">        functions like COUNT, SUM, AVG, MAX, and MIN, eg.::</span>

<span class="sd">            q = session.query(User.id).\\</span>
<span class="sd">                        join(User.addresses).\\</span>
<span class="sd">                        group_by(User.id).\\</span>
<span class="sd">                        having(func.count(Address.id) &gt; 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="n">sql</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s">&quot;having() argument must be of type &quot;</span>
                <span class="s">&quot;sqlalchemy.sql.ClauseElement or string&quot;</span><span class="p">)</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">&amp;</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="n">criterion</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a UNION of this Query against one or more queries.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            q1 = sess.query(SomeClass).filter(SomeClass.foo==&#39;bar&#39;)</span>
<span class="sd">            q2 = sess.query(SomeClass).filter(SomeClass.bar==&#39;foo&#39;)</span>

<span class="sd">            q3 = q1.union(q2)</span>

<span class="sd">        The method accepts multiple Query objects so as to control</span>
<span class="sd">        the level of nesting.  A series of ``union()`` calls such as::</span>

<span class="sd">            x.union(y).union(z).all()</span>

<span class="sd">        will nest on each ``union()``, and produces::</span>

<span class="sd">            SELECT * FROM (SELECT * FROM (SELECT * FROM X UNION</span>
<span class="sd">                            SELECT * FROM y) UNION SELECT * FROM Z)</span>

<span class="sd">        Whereas::</span>

<span class="sd">            x.union(y, z).all()</span>

<span class="sd">        produces::</span>

<span class="sd">            SELECT * FROM (SELECT * FROM X UNION SELECT * FROM y UNION</span>
<span class="sd">                            SELECT * FROM Z)</span>

<span class="sd">        Note that many database backends do not allow ORDER BY to</span>
<span class="sd">        be rendered on a query called within UNION, EXCEPT, etc.</span>
<span class="sd">        To disable all ORDER BY clauses including those configured</span>
<span class="sd">        on mappers, issue ``query.order_by(None)`` - the resulting</span>
<span class="sd">        :class:`.Query` object will not render ORDER BY within</span>
<span class="sd">        its SELECT statement.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">))))</span>

    <span class="k">def</span> <span class="nf">union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a UNION ALL of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an INTERSECT of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an INTERSECT ALL of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">intersect_all</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">except_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an EXCEPT of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">except_</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">except_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an EXCEPT ALL of this Query against one or more queries.</span>

<span class="sd">        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See</span>
<span class="sd">        that method for usage examples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_selectable</span><span class="p">(</span>
            <span class="n">expression</span><span class="o">.</span><span class="n">except_all</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a SQL JOIN against this :class:`.Query` object&#39;s criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting :class:`.Query`.</span>

<span class="sd">        **Simple Relationship Joins**</span>

<span class="sd">        Consider a mapping between two classes ``User`` and ``Address``,</span>
<span class="sd">        with a relationship ``User.addresses`` representing a collection</span>
<span class="sd">        of ``Address`` objects associated with each ``User``.   The most</span>
<span class="sd">        common usage of :meth:`~.Query.join` is to create a JOIN along this</span>
<span class="sd">        relationship, using the ``User.addresses`` attribute as an indicator</span>
<span class="sd">        for how this should occur::</span>

<span class="sd">            q = session.query(User).join(User.addresses)</span>

<span class="sd">        Where above, the call to :meth:`~.Query.join` along ``User.addresses``</span>
<span class="sd">        will result in SQL equivalent to::</span>

<span class="sd">            SELECT user.* FROM user JOIN address ON user.id = address.user_id</span>

<span class="sd">        In the above example we refer to ``User.addresses`` as passed to</span>
<span class="sd">        :meth:`~.Query.join` as the *on clause*, that is, it indicates</span>
<span class="sd">        how the &quot;ON&quot; portion of the JOIN should be constructed.  For a</span>
<span class="sd">        single-entity query such as the one above (i.e. we start by selecting</span>
<span class="sd">        only from ``User`` and nothing else), the relationship can also be</span>
<span class="sd">        specified by its string name::</span>

<span class="sd">            q = session.query(User).join(&quot;addresses&quot;)</span>

<span class="sd">        :meth:`~.Query.join` can also accommodate multiple</span>
<span class="sd">        &quot;on clause&quot; arguments to produce a chain of joins, such as below</span>
<span class="sd">        where a join across four related entities is constructed::</span>

<span class="sd">            q = session.query(User).join(&quot;orders&quot;, &quot;items&quot;, &quot;keywords&quot;)</span>

<span class="sd">        The above would be shorthand for three separate calls to</span>
<span class="sd">        :meth:`~.Query.join`, each using an explicit attribute to indicate</span>
<span class="sd">        the source entity::</span>

<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                    join(User.orders).\\</span>
<span class="sd">                    join(Order.items).\\</span>
<span class="sd">                    join(Item.keywords)</span>

<span class="sd">        **Joins to a Target Entity or Selectable**</span>

<span class="sd">        A second form of :meth:`~.Query.join` allows any mapped entity</span>
<span class="sd">        or core selectable construct as a target.   In this usage,</span>
<span class="sd">        :meth:`~.Query.join` will attempt</span>
<span class="sd">        to create a JOIN along the natural foreign key relationship between</span>
<span class="sd">        two entities::</span>

<span class="sd">            q = session.query(User).join(Address)</span>

<span class="sd">        The above calling form of :meth:`~.Query.join` will raise an error if</span>
<span class="sd">        either there are no foreign keys between the two entities, or if</span>
<span class="sd">        there are multiple foreign key linkages between them.   In the</span>
<span class="sd">        above calling form, :meth:`~.Query.join` is called upon to</span>
<span class="sd">        create the &quot;on clause&quot; automatically for us.  The target can</span>
<span class="sd">        be any mapped entity or selectable, such as a :class:`.Table`::</span>

<span class="sd">            q = session.query(User).join(addresses_table)</span>

<span class="sd">        **Joins to a Target with an ON Clause**</span>

<span class="sd">        The third calling form allows both the target entity as well</span>
<span class="sd">        as the ON clause to be passed explicitly.   Suppose for</span>
<span class="sd">        example we wanted to join to ``Address`` twice, using</span>
<span class="sd">        an alias the second time.  We use :func:`~sqlalchemy.orm.aliased`</span>
<span class="sd">        to create a distinct alias of ``Address``, and join</span>
<span class="sd">        to it using the ``target, onclause`` form, so that the</span>
<span class="sd">        alias can be specified explicitly as the target along with</span>
<span class="sd">        the relationship to instruct how the ON clause should proceed::</span>

<span class="sd">            a_alias = aliased(Address)</span>

<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                    join(User.addresses).\\</span>
<span class="sd">                    join(a_alias, User.addresses).\\</span>
<span class="sd">                    filter(Address.email_address==&#39;ed@foo.com&#39;).\\</span>
<span class="sd">                    filter(a_alias.email_address==&#39;ed@bar.com&#39;)</span>

<span class="sd">        Where above, the generated SQL would be similar to::</span>

<span class="sd">            SELECT user.* FROM user</span>
<span class="sd">                JOIN address ON user.id = address.user_id</span>
<span class="sd">                JOIN address AS address_1 ON user.id=address_1.user_id</span>
<span class="sd">                WHERE address.email_address = :email_address_1</span>
<span class="sd">                AND address_1.email_address = :email_address_2</span>

<span class="sd">        The two-argument calling form of :meth:`~.Query.join`</span>
<span class="sd">        also allows us to construct arbitrary joins with SQL-oriented</span>
<span class="sd">        &quot;on clause&quot; expressions, not relying upon configured relationships</span>
<span class="sd">        at all.  Any SQL expression can be passed as the ON clause</span>
<span class="sd">        when using the two-argument form, which should refer to the target</span>
<span class="sd">        entity in some way as well as an applicable source entity::</span>

<span class="sd">            q = session.query(User).join(Address, User.id==Address.user_id)</span>

<span class="sd">        .. versionchanged:: 0.7</span>
<span class="sd">            In SQLAlchemy 0.6 and earlier, the two argument form of</span>
<span class="sd">            :meth:`~.Query.join` requires the usage of a tuple:</span>
<span class="sd">            ``query(User).join((Address, User.id==Address.user_id))``\ .</span>
<span class="sd">            This calling form is accepted in 0.7 and further, though</span>
<span class="sd">            is not necessary unless multiple join conditions are passed to</span>
<span class="sd">            a single :meth:`~.Query.join` call, which itself is also not</span>
<span class="sd">            generally necessary as it is now equivalent to multiple</span>
<span class="sd">            calls (this wasn&#39;t always the case).</span>

<span class="sd">        **Advanced Join Targeting and Adaption**</span>

<span class="sd">        There is a lot of flexibility in what the &quot;target&quot; can be when using</span>
<span class="sd">        :meth:`~.Query.join`.   As noted previously, it also accepts</span>
<span class="sd">        :class:`.Table` constructs and other selectables such as</span>
<span class="sd">        :func:`.alias` and :func:`.select` constructs, with either the one</span>
<span class="sd">        or two-argument forms::</span>

<span class="sd">            addresses_q = select([Address.user_id]).\\</span>
<span class="sd">                        where(Address.email_address.endswith(&quot;@bar.com&quot;)).\\</span>
<span class="sd">                        alias()</span>

<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                        join(addresses_q, addresses_q.c.user_id==User.id)</span>

<span class="sd">        :meth:`~.Query.join` also features the ability to *adapt* a</span>
<span class="sd">        :meth:`~sqlalchemy.orm.relationship` -driven ON clause to the target</span>
<span class="sd">        selectable. Below we construct a JOIN from ``User`` to a subquery</span>
<span class="sd">        against ``Address``, allowing the relationship denoted by</span>
<span class="sd">        ``User.addresses`` to *adapt* itself to the altered target::</span>

<span class="sd">            address_subq = session.query(Address).\\</span>
<span class="sd">                            filter(Address.email_address == &#39;ed@foo.com&#39;).\\</span>
<span class="sd">                            subquery()</span>

<span class="sd">            q = session.query(User).join(address_subq, User.addresses)</span>

<span class="sd">        Producing SQL similar to::</span>

<span class="sd">            SELECT user.* FROM user</span>
<span class="sd">                JOIN (</span>
<span class="sd">                    SELECT address.id AS id,</span>
<span class="sd">                            address.user_id AS user_id,</span>
<span class="sd">                            address.email_address AS email_address</span>
<span class="sd">                    FROM address</span>
<span class="sd">                    WHERE address.email_address = :email_address_1</span>
<span class="sd">                ) AS anon_1 ON user.id = anon_1.user_id</span>

<span class="sd">        The above form allows one to fall back onto an explicit ON</span>
<span class="sd">        clause at any time::</span>

<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                    join(address_subq, User.id==address_subq.c.user_id)</span>

<span class="sd">        **Controlling what to Join From**</span>

<span class="sd">        While :meth:`~.Query.join` exclusively deals with the &quot;right&quot;</span>
<span class="sd">        side of the JOIN, we can also control the &quot;left&quot; side, in those</span>
<span class="sd">        cases where it&#39;s needed, using :meth:`~.Query.select_from`.</span>
<span class="sd">        Below we construct a query against ``Address`` but can still</span>
<span class="sd">        make usage of ``User.addresses`` as our ON clause by instructing</span>
<span class="sd">        the :class:`.Query` to select first from the ``User``</span>
<span class="sd">        entity::</span>

<span class="sd">            q = session.query(Address).select_from(User).\\</span>
<span class="sd">                            join(User.addresses).\\</span>
<span class="sd">                            filter(User.name == &#39;ed&#39;)</span>

<span class="sd">        Which will produce SQL similar to::</span>

<span class="sd">            SELECT address.* FROM user</span>
<span class="sd">                JOIN address ON user.id=address.user_id</span>
<span class="sd">                WHERE user.name = :name_1</span>

<span class="sd">        **Constructing Aliases Anonymously**</span>

<span class="sd">        :meth:`~.Query.join` can construct anonymous aliases</span>
<span class="sd">        using the ``aliased=True`` flag.  This feature is useful</span>
<span class="sd">        when a query is being joined algorithmically, such as</span>
<span class="sd">        when querying self-referentially to an arbitrary depth::</span>

<span class="sd">            q = session.query(Node).\\</span>
<span class="sd">                    join(&quot;children&quot;, &quot;children&quot;, aliased=True)</span>

<span class="sd">        When ``aliased=True`` is used, the actual &quot;alias&quot; construct</span>
<span class="sd">        is not explicitly available.  To work with it, methods such as</span>
<span class="sd">        :meth:`.Query.filter` will adapt the incoming entity to</span>
<span class="sd">        the last join point::</span>

<span class="sd">            q = session.query(Node).\\</span>
<span class="sd">                    join(&quot;children&quot;, &quot;children&quot;, aliased=True).\\</span>
<span class="sd">                    filter(Node.name == &#39;grandchild 1&#39;)</span>

<span class="sd">        When using automatic aliasing, the ``from_joinpoint=True``</span>
<span class="sd">        argument can allow a multi-node join to be broken into</span>
<span class="sd">        multiple calls to :meth:`~.Query.join`, so that</span>
<span class="sd">        each path along the way can be further filtered::</span>

<span class="sd">            q = session.query(Node).\\</span>
<span class="sd">                    join(&quot;children&quot;, aliased=True).\\</span>
<span class="sd">                    filter(Node.name=&#39;child 1&#39;).\\</span>
<span class="sd">                    join(&quot;children&quot;, aliased=True, from_joinpoint=True).\\</span>
<span class="sd">                    filter(Node.name == &#39;grandchild 1&#39;)</span>

<span class="sd">        The filtering aliases above can then be reset back to the</span>
<span class="sd">        original ``Node`` entity using :meth:`~.Query.reset_joinpoint`::</span>

<span class="sd">            q = session.query(Node).\\</span>
<span class="sd">                    join(&quot;children&quot;, &quot;children&quot;, aliased=True).\\</span>
<span class="sd">                    filter(Node.name == &#39;grandchild 1&#39;).\\</span>
<span class="sd">                    reset_joinpoint().\\</span>
<span class="sd">                    filter(Node.name == &#39;parent 1)</span>

<span class="sd">        For an example of ``aliased=True``, see the distribution</span>
<span class="sd">        example :ref:`examples_xmlpersistence` which illustrates</span>
<span class="sd">        an XPath-like query system using algorithmic joins.</span>

<span class="sd">        :param \*props: A collection of one or more join conditions,</span>
<span class="sd">         each consisting of a relationship-bound attribute or string</span>
<span class="sd">         relationship name representing an &quot;on clause&quot;, or a single</span>
<span class="sd">         target entity, or a tuple in the form of ``(target, onclause)``.</span>
<span class="sd">         A special two-argument calling form of the form ``target, onclause``</span>
<span class="sd">         is also accepted.</span>
<span class="sd">        :param aliased=False: If True, indicate that the JOIN target should be</span>
<span class="sd">         anonymously aliased.  Subsequent calls to :meth:`~.Query.filter`</span>
<span class="sd">         and similar will adapt the incoming criterion to the target</span>
<span class="sd">         alias, until :meth:`~.Query.reset_joinpoint` is called.</span>
<span class="sd">        :param isouter=False: If True, the join used will be a left outer join,</span>
<span class="sd">         just as if the :meth:`.Query.outerjoin` method were called.  This</span>
<span class="sd">         flag is here to maintain consistency with the same flag as accepted</span>
<span class="sd">         by :meth:`.FromClause.join` and other Core constructs.</span>


<span class="sd">         .. versionadded:: 1.0.0</span>

<span class="sd">        :param from_joinpoint=False: When using ``aliased=True``, a setting</span>
<span class="sd">         of True here will cause the join to be from the most recent</span>
<span class="sd">         joined target, rather than starting back from the original</span>
<span class="sd">         FROM clauses of the query.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`ormtutorial_joins` in the ORM tutorial.</span>

<span class="sd">            :ref:`inheritance_toplevel` for details on how</span>
<span class="sd">            :meth:`~.Query.join` is used for inheritance relationships.</span>

<span class="sd">            :func:`.orm.join` - a standalone ORM-level join function,</span>
<span class="sd">            used internally by :meth:`.Query.join`, which in previous</span>
<span class="sd">            SQLAlchemy versions was the primary ORM-level joining interface.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aliased</span><span class="p">,</span> <span class="n">from_joinpoint</span><span class="p">,</span> <span class="n">isouter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;aliased&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>\
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;from_joinpoint&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>\
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;isouter&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;unknown arguments: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                            <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">props</span><span class="p">,</span>
                          <span class="n">outerjoin</span><span class="o">=</span><span class="n">isouter</span><span class="p">,</span> <span class="n">create_aliases</span><span class="o">=</span><span class="n">aliased</span><span class="p">,</span>
                          <span class="n">from_joinpoint</span><span class="o">=</span><span class="n">from_joinpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">outerjoin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a left outer join against this ``Query`` object&#39;s criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting ``Query``.</span>

<span class="sd">        Usage is the same as the ``join()`` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aliased</span><span class="p">,</span> <span class="n">from_joinpoint</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;aliased&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span> \
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;from_joinpoint&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;unknown arguments: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                            <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">props</span><span class="p">,</span>
                          <span class="n">outerjoin</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">create_aliases</span><span class="o">=</span><span class="n">aliased</span><span class="p">,</span>
                          <span class="n">from_joinpoint</span><span class="o">=</span><span class="n">from_joinpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_joinpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span> <span class="o">=</span> <span class="n">jp</span>
        <span class="c"># copy backwards to the root of the _joinpath</span>
        <span class="c"># dict, so that no existing dict in the path is mutated</span>
        <span class="k">while</span> <span class="s">&#39;prev&#39;</span> <span class="ow">in</span> <span class="n">jp</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">jp</span><span class="p">[</span><span class="s">&#39;prev&#39;</span><span class="p">]</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">prev</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">jp</span>
            <span class="n">jp</span><span class="p">[</span><span class="s">&#39;prev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span>
            <span class="n">jp</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinpath</span> <span class="o">=</span> <span class="n">jp</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">,</span> <span class="n">_no_limit_offset</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span> <span class="n">from_joinpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;consumes arguments from join() or outerjoin(), places them into a</span>
<span class="sd">        consistent format with which to form the actual JOIN constructs.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_joinpoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_joinpoint</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> \
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">FromClause</span><span class="p">,</span>
                                 <span class="nb">type</span><span class="p">,</span> <span class="n">AliasedClass</span><span class="p">))</span> <span class="ow">and</span> \
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">,</span>
                                 <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">)):</span>
            <span class="c"># detect 2-arg form of join and</span>
            <span class="c"># convert to a tuple.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">(</span><span class="n">keys</span><span class="p">,)</span>

        <span class="n">keylist</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keylist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c"># &quot;tuple&quot; form of join, multiple</span>
                <span class="c"># tuples are accepted as well.   The simpler</span>
                <span class="c"># &quot;2-arg&quot; form is preferred.  May deprecate</span>
                <span class="c"># the &quot;tuple&quot; usage.</span>
                <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">=</span> <span class="n">arg1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg2</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># determine onclause/right_entity.  there</span>
            <span class="c"># is a little bit of legacy behavior still at work here</span>
            <span class="c"># which means they might be in either order.  may possibly</span>
            <span class="c"># lock this down to (right_entity, onclause) in 0.6.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">arg1</span><span class="p">,</span> <span class="p">(</span><span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
                <span class="n">right_entity</span><span class="p">,</span> <span class="n">onclause</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right_entity</span><span class="p">,</span> <span class="n">onclause</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span>

            <span class="n">left_entity</span> <span class="o">=</span> <span class="n">prop</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">):</span>
                <span class="n">of_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="s">&#39;_of_type&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">of_type</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">left_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">()</span>

                <span class="n">descriptor</span> <span class="o">=</span> <span class="n">_entity_descriptor</span><span class="p">(</span><span class="n">left_entity</span><span class="p">,</span> <span class="n">onclause</span><span class="p">)</span>
                <span class="n">onclause</span> <span class="o">=</span> <span class="n">descriptor</span>

            <span class="c"># check for q.join(Class.propname, from_joinpoint=True)</span>
            <span class="c"># and Class is that of the current joinpoint</span>
            <span class="k">elif</span> <span class="n">from_joinpoint</span> <span class="ow">and</span> \
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">):</span>
                <span class="n">left_entity</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">_parententity</span>

                <span class="n">info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">())</span>
                <span class="n">left_mapper</span><span class="p">,</span> <span class="n">left_selectable</span><span class="p">,</span> <span class="n">left_is_aliased</span> <span class="o">=</span> \
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&#39;mapper&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> \
                    <span class="n">info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> \
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&#39;is_aliased_class&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">left_mapper</span> <span class="ow">is</span> <span class="n">left_entity</span><span class="p">:</span>
                    <span class="n">left_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint_zero</span><span class="p">()</span>
                    <span class="n">descriptor</span> <span class="o">=</span> <span class="n">_entity_descriptor</span><span class="p">(</span><span class="n">left_entity</span><span class="p">,</span>
                                                    <span class="n">onclause</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">onclause</span> <span class="o">=</span> <span class="n">descriptor</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">right_entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">of_type</span><span class="p">:</span>
                        <span class="n">right_entity</span> <span class="o">=</span> <span class="n">of_type</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">right_entity</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">property</span><span class="o">.</span><span class="n">mapper</span>

                <span class="n">left_entity</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">_parententity</span>

                <span class="n">prop</span> <span class="o">=</span> <span class="n">onclause</span><span class="o">.</span><span class="n">property</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">attributes</span><span class="o">.</span><span class="n">QueryableAttribute</span><span class="p">):</span>
                    <span class="n">onclause</span> <span class="o">=</span> <span class="n">prop</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
                    <span class="c"># check for this path already present.</span>
                    <span class="c"># don&#39;t render in that case.</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">left_entity</span><span class="p">,</span> <span class="n">right_entity</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">:</span>
                        <span class="c"># The child&#39;s prev reference might be stale --</span>
                        <span class="c"># it could point to a parent older than the</span>
                        <span class="c"># current joinpoint.  If this is the case,</span>
                        <span class="c"># then we need to update it and then fix the</span>
                        <span class="c"># tree&#39;s spine with _update_joinpoint.  Copy</span>
                        <span class="c"># and then mutate the child, which might be</span>
                        <span class="c"># shared by a different query object.</span>
                        <span class="n">jp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">jp</span><span class="p">[</span><span class="s">&#39;prev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_update_joinpoint</span><span class="p">(</span><span class="n">jp</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">keylist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                <span class="s">&quot;Pathed join target </span><span class="si">%s</span><span class="s"> has already &quot;</span>
                                <span class="s">&quot;been joined to; skipping&quot;</span> <span class="o">%</span> <span class="n">prop</span><span class="p">)</span>
                        <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">onclause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">right_entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># TODO: no coverage here</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;query.join(a==b) not supported.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_join_left_to_right</span><span class="p">(</span>
                <span class="n">left_entity</span><span class="p">,</span>
                <span class="n">right_entity</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span>
                <span class="n">outerjoin</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_join_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span>
                            <span class="n">onclause</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;append a JOIN to the query&#39;s from clause.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">entity_zero_or_selectable</span>

        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Don&#39;t know how to join from </span><span class="si">%s</span><span class="s">; please use &quot;</span>
                <span class="s">&quot;select_from() to establish the left &quot;</span>
                <span class="s">&quot;entity/selectable of this join&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="n">right</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Can&#39;t construct a join from </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">, they &quot;</span>
                <span class="s">&quot;are the same entity&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

        <span class="n">l_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">r_info</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
            <span class="n">right_mapper</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">r_info</span><span class="p">,</span> <span class="s">&quot;mapper&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c"># if the target is a joined inheritance mapping,</span>
            <span class="c"># be more liberal about auto-aliasing.</span>
            <span class="k">if</span> <span class="n">right_mapper</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">right_mapper</span><span class="o">.</span><span class="n">with_polymorphic</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_mapper</span><span class="o">.</span><span class="n">mapped_table</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">Join</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">from_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="ow">or</span> <span class="p">[</span><span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">selectables_overlap</span><span class="p">(</span>
                            <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> <span class="n">from_obj</span><span class="p">)</span> <span class="ow">and</span> \
                            <span class="n">sql_util</span><span class="o">.</span><span class="n">selectables_overlap</span><span class="p">(</span>
                                <span class="n">from_obj</span><span class="p">,</span> <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">):</span>
                        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">break</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">overlap</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span> <span class="ow">is</span> <span class="n">r_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Can&#39;t join table/selectable &#39;</span><span class="si">%s</span><span class="s">&#39; to itself&quot;</span> <span class="o">%</span>
                <span class="n">l_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">)</span>

        <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_right_side</span><span class="p">(</span>
            <span class="n">r_info</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span>
            <span class="n">create_aliases</span><span class="p">,</span>
            <span class="n">prop</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>

        <span class="c"># if joining on a MapperProperty path,</span>
        <span class="c"># track the path to prevent redundant joins</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_aliases</span> <span class="ow">and</span> <span class="n">prop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_joinpoint</span><span class="p">({</span>
                <span class="s">&#39;_joinpoint_entity&#39;</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span>
                <span class="s">&#39;prev&#39;</span><span class="p">:</span> <span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">key</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;_joinpoint_entity&#39;</span><span class="p">:</span> <span class="n">right</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_join_to_left</span><span class="p">(</span><span class="n">l_info</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_right_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_info</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">create_aliases</span><span class="p">,</span>
                            <span class="n">prop</span><span class="p">,</span> <span class="n">overlap</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">r_info</span>

        <span class="n">right_mapper</span><span class="p">,</span> <span class="n">right_selectable</span><span class="p">,</span> <span class="n">right_is_aliased</span> <span class="o">=</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&#39;mapper&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> \
            <span class="n">info</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&#39;is_aliased_class&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">right_mapper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_join_entities</span> <span class="o">+=</span> <span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">right_mapper</span> <span class="ow">and</span> <span class="n">prop</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">right_mapper</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">mapper</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Join target </span><span class="si">%s</span><span class="s"> does not correspond to &quot;</span>
                <span class="s">&quot;the right side of join condition </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">right_mapper</span> <span class="ow">and</span> <span class="n">prop</span><span class="p">:</span>
            <span class="n">right_mapper</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">mapper</span>

        <span class="n">need_adapter</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">right_mapper</span> <span class="ow">and</span> <span class="n">right</span> <span class="ow">is</span> <span class="n">right_selectable</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">right_selectable</span><span class="o">.</span><span class="n">is_derived_from</span><span class="p">(</span>
                    <span class="n">right_mapper</span><span class="o">.</span><span class="n">mapped_table</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s">&quot;Selectable &#39;</span><span class="si">%s</span><span class="s">&#39; is not derived from &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">right_selectable</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                     <span class="n">right_mapper</span><span class="o">.</span><span class="n">mapped_table</span><span class="o">.</span><span class="n">description</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_selectable</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">):</span>
                <span class="c"># TODO: this isn&#39;t even covered now!</span>
                <span class="n">right_selectable</span> <span class="o">=</span> <span class="n">right_selectable</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
                <span class="n">need_adapter</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="n">right</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">right_mapper</span><span class="p">,</span> <span class="n">right_selectable</span><span class="p">)</span>

        <span class="n">aliased_entity</span> <span class="o">=</span> <span class="n">right_mapper</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="n">right_is_aliased</span> <span class="ow">and</span> \
            <span class="p">(</span>
                <span class="n">right_mapper</span><span class="o">.</span><span class="n">with_polymorphic</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">right_mapper</span><span class="o">.</span><span class="n">_with_polymorphic_selectable</span><span class="p">,</span>
                    <span class="n">expression</span><span class="o">.</span><span class="n">Alias</span><span class="p">)</span>
                <span class="ow">or</span>
                <span class="n">overlap</span>  <span class="c"># test for overlap:</span>
                <span class="c"># orm/inheritance/relationships.py</span>
                <span class="c"># SelfReferentialM2MTest</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">need_adapter</span> <span class="ow">and</span> <span class="p">(</span><span class="n">create_aliases</span> <span class="ow">or</span> <span class="n">aliased_entity</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">need_adapter</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># if an alias() of the right side was generated here,</span>
        <span class="c"># apply an adapter to all subsequent filter() calls</span>
        <span class="c"># until reset_joinpoint() is called.</span>
        <span class="k">if</span> <span class="n">need_adapter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span> <span class="o">=</span> <span class="n">ORMAdapter</span><span class="p">(</span>
                <span class="n">right</span><span class="p">,</span>
                <span class="n">equivalents</span><span class="o">=</span><span class="n">right_mapper</span> <span class="ow">and</span>
                <span class="n">right_mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span> <span class="ow">or</span> <span class="p">{},</span>
                <span class="n">chain_to</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span><span class="p">)</span>

        <span class="c"># if the onclause is a ClauseElement, adapt it with any</span>
        <span class="c"># adapters that are in place right now</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">):</span>
            <span class="n">onclause</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">onclause</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c"># if an alias() on the right side was generated,</span>
        <span class="c"># which is intended to wrap a the right side in a subquery,</span>
        <span class="c"># ensure that columns retrieved from this target in the result</span>
        <span class="c"># set are also adapted.</span>
        <span class="k">if</span> <span class="n">aliased_entity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">create_aliases</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper_loads_polymorphically_with</span><span class="p">(</span>
                <span class="n">right_mapper</span><span class="p">,</span>
                <span class="n">ORMAdapter</span><span class="p">(</span>
                    <span class="n">right</span><span class="p">,</span>
                    <span class="n">equivalents</span><span class="o">=</span><span class="n">right_mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span>

    <span class="k">def</span> <span class="nf">_join_to_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_info</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">outerjoin</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">l_info</span>
        <span class="n">left_mapper</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&#39;mapper&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">left_selectable</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">selectable</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">:</span>
            <span class="n">replace_clause_index</span><span class="p">,</span> <span class="n">clause</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">find_join_source</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">,</span>
                <span class="n">left_selectable</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">clause</span> <span class="o">=</span> <span class="n">orm_join</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span>
                                      <span class="n">right</span><span class="p">,</span>
                                      <span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">outerjoin</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span> <span class="k">as</span> <span class="n">ae</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s">&quot;Could not find a FROM clause to join from.  &quot;</span>
                        <span class="s">&quot;Tried joining to </span><span class="si">%s</span><span class="s">, but got: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ae</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[:</span><span class="n">replace_clause_index</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span><span class="p">[</span><span class="n">replace_clause_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">left_mapper</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ent</span><span class="o">.</span><span class="n">corresponds_to</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
                    <span class="n">clause</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">selectable</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">clause</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clause</span> <span class="o">=</span> <span class="n">left_selectable</span>

        <span class="k">assert</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clause</span> <span class="o">=</span> <span class="n">orm_join</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">outerjoin</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span> <span class="k">as</span> <span class="n">ae</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;Could not find a FROM clause to join from.  &quot;</span>
                <span class="s">&quot;Tried joining to </span><span class="si">%s</span><span class="s">, but got: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ae</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_obj</span> <span class="o">+</span> <span class="p">(</span><span class="n">clause</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">_reset_joinpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinpoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinpath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter_aliases</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reset_joinpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Query`, where the &quot;join point&quot; has</span>
<span class="sd">        been reset back to the base FROM entities of the query.</span>

<span class="sd">        This method is usually used in conjunction with the</span>
<span class="sd">        ``aliased=True`` feature of the :meth:`~.Query.join`</span>
<span class="sd">        method.  See the example in :meth:`~.Query.join` for how</span>
<span class="sd">        this is used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_joinpoint</span><span class="p">()</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">select_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">from_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the FROM clause of this :class:`.Query` explicitly.</span>

<span class="sd">        :meth:`.Query.select_from` is often used in conjunction with</span>
<span class="sd">        :meth:`.Query.join` in order to control which entity is selected</span>
<span class="sd">        from on the &quot;left&quot; side of the join.</span>

<span class="sd">        The entity or selectable object here effectively replaces the</span>
<span class="sd">        &quot;left edge&quot; of any calls to :meth:`~.Query.join`, when no</span>
<span class="sd">        joinpoint is otherwise established - usually, the default &quot;join</span>
<span class="sd">        point&quot; is the leftmost entity in the :class:`~.Query` object&#39;s</span>
<span class="sd">        list of entities to be selected.</span>

<span class="sd">        A typical example::</span>

<span class="sd">            q = session.query(Address).select_from(User).\\</span>
<span class="sd">                join(User.addresses).\\</span>
<span class="sd">                filter(User.name == &#39;ed&#39;)</span>

<span class="sd">        Which produces SQL equivalent to::</span>

<span class="sd">            SELECT address.* FROM user</span>
<span class="sd">            JOIN address ON user.id=address.user_id</span>
<span class="sd">            WHERE user.name = :name_1</span>

<span class="sd">        :param \*from_obj: collection of one or more entities to apply</span>
<span class="sd">         to the FROM clause.  Entities can be mapped classes,</span>
<span class="sd">         :class:`.AliasedClass` objects, :class:`.Mapper` objects</span>
<span class="sd">         as well as core :class:`.FromClause` elements like subqueries.</span>

<span class="sd">        .. versionchanged:: 0.9</span>
<span class="sd">            This method no longer applies the given FROM object</span>
<span class="sd">            to be the selectable from which matching entities</span>
<span class="sd">            select from; the :meth:`.select_entity_from` method</span>
<span class="sd">            now accomplishes this.  See that method for a description</span>
<span class="sd">            of this behavior.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`~.Query.join`</span>

<span class="sd">            :meth:`.Query.select_entity_from`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_select_from</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">select_entity_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the FROM clause of this :class:`.Query` to a</span>
<span class="sd">        core selectable, applying it as a replacement FROM clause</span>
<span class="sd">        for corresponding mapped entities.</span>

<span class="sd">        This method is similar to the :meth:`.Query.select_from`</span>
<span class="sd">        method, in that it sets the FROM clause of the query.  However,</span>
<span class="sd">        where :meth:`.Query.select_from` only affects what is placed</span>
<span class="sd">        in the FROM, this method also applies the given selectable</span>
<span class="sd">        to replace the FROM which the selected entities would normally</span>
<span class="sd">        select from.</span>

<span class="sd">        The given ``from_obj`` must be an instance of a :class:`.FromClause`,</span>
<span class="sd">        e.g. a :func:`.select` or :class:`.Alias` construct.</span>

<span class="sd">        An example would be a :class:`.Query` that selects ``User`` entities,</span>
<span class="sd">        but uses :meth:`.Query.select_entity_from` to have the entities</span>
<span class="sd">        selected from a :func:`.select` construct instead of the</span>
<span class="sd">        base ``user`` table::</span>

<span class="sd">            select_stmt = select([User]).where(User.id == 7)</span>

<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                    select_entity_from(select_stmt).\\</span>
<span class="sd">                    filter(User.name == &#39;ed&#39;)</span>

<span class="sd">        The query generated will select ``User`` entities directly</span>
<span class="sd">        from the given :func:`.select` construct, and will be::</span>

<span class="sd">            SELECT anon_1.id AS anon_1_id, anon_1.name AS anon_1_name</span>
<span class="sd">            FROM (SELECT &quot;user&quot;.id AS id, &quot;user&quot;.name AS name</span>
<span class="sd">            FROM &quot;user&quot;</span>
<span class="sd">            WHERE &quot;user&quot;.id = :id_1) AS anon_1</span>
<span class="sd">            WHERE anon_1.name = :name_1</span>

<span class="sd">        Notice above that even the WHERE criterion was &quot;adapted&quot; such that</span>
<span class="sd">        the ``anon_1`` subquery effectively replaces all references to the</span>
<span class="sd">        ``user`` table, except for the one that it refers to internally.</span>

<span class="sd">        Compare this to :meth:`.Query.select_from`, which as of</span>
<span class="sd">        version 0.9, does not affect existing entities.  The</span>
<span class="sd">        statement below::</span>

<span class="sd">            q = session.query(User).\\</span>
<span class="sd">                    select_from(select_stmt).\\</span>
<span class="sd">                    filter(User.name == &#39;ed&#39;)</span>

<span class="sd">        Produces SQL where both the ``user`` table as well as the</span>
<span class="sd">        ``select_stmt`` construct are present as separate elements</span>
<span class="sd">        in the FROM clause.  No &quot;adaptation&quot; of the ``user`` table</span>
<span class="sd">        is applied::</span>

<span class="sd">            SELECT &quot;user&quot;.id AS user_id, &quot;user&quot;.name AS user_name</span>
<span class="sd">            FROM &quot;user&quot;, (SELECT &quot;user&quot;.id AS id, &quot;user&quot;.name AS name</span>
<span class="sd">            FROM &quot;user&quot;</span>
<span class="sd">            WHERE &quot;user&quot;.id = :id_1) AS anon_1</span>
<span class="sd">            WHERE &quot;user&quot;.name = :name_1</span>

<span class="sd">        :meth:`.Query.select_entity_from` maintains an older</span>
<span class="sd">        behavior of :meth:`.Query.select_from`.  In modern usage,</span>
<span class="sd">        similar results can also be achieved using :func:`.aliased`::</span>

<span class="sd">            select_stmt = select([User]).where(User.id == 7)</span>
<span class="sd">            user_from_select = aliased(User, select_stmt.alias())</span>

<span class="sd">            q = session.query(user_from_select)</span>

<span class="sd">        :param from_obj: a :class:`.FromClause` object that will replace</span>
<span class="sd">         the FROM clause of this :class:`.Query`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.select_from`</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">            :meth:`.Query.select_entity_from` was added to specify</span>
<span class="sd">            the specific behavior of entity replacement, however</span>
<span class="sd">            the :meth:`.Query.select_from` maintains this behavior</span>
<span class="sd">            as well until 0.9.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_select_from</span><span class="p">([</span><span class="n">from_obj</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">decode_slice</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c"># perhaps we should execute a count() here so that we</span>
            <span class="c"># can still use LIMIT/OFFSET ?</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> \
                    <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">item</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">)[</span><span class="bp">None</span><span class="p">:</span><span class="bp">None</span><span class="p">:</span><span class="n">item</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">:</span><span class="n">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;apply LIMIT/OFFSET to the ``Query`` based on a &quot;</span>
<span class="sd">        &quot;range and return the newly resulting ``Query``.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a ``LIMIT`` to the query and return the newly resulting</span>

<span class="sd">        ``Query``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">limit</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply an ``OFFSET`` to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_statement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a ``DISTINCT`` to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>


<span class="sd">        .. note::</span>

<span class="sd">            The :meth:`.distinct` call includes logic that will automatically</span>
<span class="sd">            add columns from the ORDER BY of the query to the columns</span>
<span class="sd">            clause of the SELECT statement, to satisfy the common need</span>
<span class="sd">            of the database backend that ORDER BY columns be part of the</span>
<span class="sd">            SELECT list when DISTINCT is used.   These columns *are not*</span>
<span class="sd">            added to the list of columns actually fetched by the</span>
<span class="sd">            :class:`.Query`, however, so would not affect results.</span>
<span class="sd">            The columns are passed through when using the</span>
<span class="sd">            :attr:`.Query.statement` accessor, however.</span>

<span class="sd">        :param \*expr: optional column expressions.  When present,</span>
<span class="sd">         the Postgresql dialect will render a ``DISTINCT ON (&lt;expressions&gt;&gt;)``</span>
<span class="sd">         construct.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">criterion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_col_list</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">+=</span> <span class="n">criterion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="n">criterion</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">prefix_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">prefixes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the prefixes to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        :param \*prefixes: optional prefixes, typically strings,</span>
<span class="sd">         not using any commas.   In particular is useful for MySQL keywords.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            query = sess.query(User.name).\\</span>
<span class="sd">                prefix_with(&#39;HIGH_PRIORITY&#39;).\\</span>
<span class="sd">                prefix_with(&#39;SQL_SMALL_RESULT&#39;, &#39;ALL&#39;)</span>

<span class="sd">        Would render::</span>

<span class="sd">            SELECT HIGH_PRIORITY SQL_SMALL_RESULT ALL users.name AS users_name</span>
<span class="sd">            FROM users</span>

<span class="sd">        .. versionadded:: 0.7.7</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.HasPrefixes.prefix_with`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">+=</span> <span class="n">prefixes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span> <span class="o">=</span> <span class="n">prefixes</span>

    <span class="nd">@_generative</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">suffix_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">suffixes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the suffix to the query and return the newly resulting</span>
<span class="sd">        ``Query``.</span>

<span class="sd">        :param \*suffixes: optional suffixes, typically strings,</span>
<span class="sd">         not using any commas.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.prefix_with`</span>

<span class="sd">            :meth:`.HasSuffixes.suffix_with`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">+=</span> <span class="n">suffixes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span> <span class="o">=</span> <span class="n">suffixes</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the results represented by this ``Query`` as a list.</span>

<span class="sd">        This results in an execution of the underlying query.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_generative</span><span class="p">(</span><span class="n">_no_clauseelement_condition</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the given SELECT statement and return results.</span>

<span class="sd">        This method bypasses all internal statement compilation, and the</span>
<span class="sd">        statement is executed without modification.</span>

<span class="sd">        The statement is typically either a :func:`~.expression.text`</span>
<span class="sd">        or :func:`~.expression.select` construct, and should return the set</span>
<span class="sd">        of columns</span>
<span class="sd">        appropriate to the entity class represented by this :class:`.Query`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`orm_tutorial_literal_sql` - usage examples in the</span>
<span class="sd">            ORM tutorial</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">statement</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span>
                          <span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">TextClause</span><span class="p">,</span>
                           <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s">&quot;from_statement accepts text(), select(), &quot;</span>
                <span class="s">&quot;and union() objects only.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="o">=</span> <span class="n">statement</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first result of this ``Query`` or</span>
<span class="sd">        None if the result doesn&#39;t contain any row.</span>

<span class="sd">        first() applies a limit of one within the generated SQL, so that</span>
<span class="sd">        only one primary entity row is generated on the server side</span>
<span class="sd">        (note this may consist of multiple result rows if join-loaded</span>
<span class="sd">        collections are present).</span>

<span class="sd">        Calling :meth:`.Query.first` results in an execution of the underlying query.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">one_or_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return at most one result or raise an exception.</span>

<span class="sd">        Returns ``None`` if the query selects</span>
<span class="sd">        no rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound``</span>
<span class="sd">        if multiple object identities are returned, or if multiple</span>
<span class="sd">        rows are returned for a query that returns only scalar values</span>
<span class="sd">        as opposed to full identity-mapped entities.</span>

<span class="sd">        Calling :meth:`.Query.one_or_none` results in an execution of the underlying</span>
<span class="sd">        query.</span>

<span class="sd">        .. versionadded:: 1.0.9</span>

<span class="sd">            Added :meth:`.Query.one_or_none`</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.first`</span>

<span class="sd">            :meth:`.Query.one`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">MultipleResultsFound</span><span class="p">(</span>
                <span class="s">&quot;Multiple rows were found for one_or_none()&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return exactly one result or raise an exception.</span>

<span class="sd">        Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query selects</span>
<span class="sd">        no rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound``</span>
<span class="sd">        if multiple object identities are returned, or if multiple</span>
<span class="sd">        rows are returned for a query that returns only scalar values</span>
<span class="sd">        as opposed to full identity-mapped entities.</span>

<span class="sd">        Calling :meth:`.one` results in an execution of the underlying query.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.first`</span>

<span class="sd">            :meth:`.Query.one_or_none`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">NoResultFound</span><span class="p">(</span><span class="s">&quot;No row was found for one()&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">MultipleResultsFound</span><span class="p">(</span>
                <span class="s">&quot;Multiple rows were found for one()&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first element of the first result or None</span>
<span class="sd">        if no rows present.  If multiple rows are returned,</span>
<span class="sd">        raises MultipleResultsFound.</span>

<span class="sd">          &gt;&gt;&gt; session.query(Item).scalar()</span>
<span class="sd">          &lt;Item&gt;</span>
<span class="sd">          &gt;&gt;&gt; session.query(Item.id).scalar()</span>
<span class="sd">          1</span>
<span class="sd">          &gt;&gt;&gt; session.query(Item.id).filter(Item.id &lt; 0).scalar()</span>
<span class="sd">          None</span>
<span class="sd">          &gt;&gt;&gt; session.query(Item.id, Item.name).scalar()</span>
<span class="sd">          1</span>
<span class="sd">          &gt;&gt;&gt; session.query(func.count(Parent.id)).scalar()</span>
<span class="sd">          20</span>

<span class="sd">        This results in an execution of the underlying query.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">orm_exc</span><span class="o">.</span><span class="n">NoResultFound</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_context</span><span class="p">()</span>
        <span class="n">context</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">use_labels</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_populate_existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_autoflush</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_and_instances</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_connection_from_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">(</span>
            <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">_execute_and_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">querycontext</span><span class="p">):</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_from_session</span><span class="p">(</span>
            <span class="n">mapper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bind_mapper</span><span class="p">(),</span>
            <span class="n">clause</span><span class="o">=</span><span class="n">querycontext</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span>
            <span class="n">close_with_result</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">querycontext</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">querycontext</span><span class="o">.</span><span class="n">query</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">querycontext</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">column_descriptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return metadata about the columns which would be</span>
<span class="sd">        returned by this :class:`.Query`.</span>

<span class="sd">        Format is a list of dictionaries::</span>

<span class="sd">            user_alias = aliased(User, name=&#39;user2&#39;)</span>
<span class="sd">            q = sess.query(User, User.id, user_alias)</span>

<span class="sd">            # this expression:</span>
<span class="sd">            q.column_descriptions</span>

<span class="sd">            # would return:</span>
<span class="sd">            [</span>
<span class="sd">                {</span>
<span class="sd">                    &#39;name&#39;:&#39;User&#39;,</span>
<span class="sd">                    &#39;type&#39;:User,</span>
<span class="sd">                    &#39;aliased&#39;:False,</span>
<span class="sd">                    &#39;expr&#39;:User,</span>
<span class="sd">                    &#39;entity&#39;: User</span>
<span class="sd">                },</span>
<span class="sd">                {</span>
<span class="sd">                    &#39;name&#39;:&#39;id&#39;,</span>
<span class="sd">                    &#39;type&#39;:Integer(),</span>
<span class="sd">                    &#39;aliased&#39;:False,</span>
<span class="sd">                    &#39;expr&#39;:User.id,</span>
<span class="sd">                    &#39;entity&#39;: User</span>
<span class="sd">                },</span>
<span class="sd">                {</span>
<span class="sd">                    &#39;name&#39;:&#39;user2&#39;,</span>
<span class="sd">                    &#39;type&#39;:User,</span>
<span class="sd">                    &#39;aliased&#39;:True,</span>
<span class="sd">                    &#39;expr&#39;:user_alias,</span>
<span class="sd">                    &#39;entity&#39;: user_alias</span>
<span class="sd">                }</span>
<span class="sd">            ]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="n">ent</span><span class="o">.</span><span class="n">_label_name</span><span class="p">,</span>
                <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="n">ent</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="s">&#39;aliased&#39;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">insp_ent</span><span class="p">,</span> <span class="s">&#39;is_aliased_class&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                <span class="s">&#39;expr&#39;</span><span class="p">:</span> <span class="n">ent</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                <span class="s">&#39;entity&#39;</span><span class="p">:</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">insp_ent</span><span class="p">,</span> <span class="s">&quot;entity&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">insp_ent</span><span class="o">.</span><span class="n">is_clause_element</span>
                    <span class="k">else</span> <span class="bp">None</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">ent</span><span class="p">,</span> <span class="n">insp_ent</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">_ent</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">inspect</span><span class="p">(</span><span class="n">_ent</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">_ent</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">_ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span>
            <span class="p">]</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">__context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a ResultProxy cursor as returned by connection.execute(),</span>
<span class="sd">        return an ORM result as an iterator.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            result = engine.execute(&quot;select * from users&quot;)</span>
<span class="sd">            for u in session.query(User).instances(result):</span>
<span class="sd">                print u</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">__context</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">QueryContext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge a result into this :class:`.Query` object&#39;s Session.</span>

<span class="sd">        Given an iterator returned by a :class:`.Query` of the same structure</span>
<span class="sd">        as this one, return an identical iterator of results, with all mapped</span>
<span class="sd">        instances merged into the session using :meth:`.Session.merge`. This</span>
<span class="sd">        is an optimized method which will merge all mapped instances,</span>
<span class="sd">        preserving the structure of the result rows and unmapped columns with</span>
<span class="sd">        less method overhead than that of calling :meth:`.Session.merge`</span>
<span class="sd">        explicitly for each value.</span>

<span class="sd">        The structure of the results is determined based on the column list of</span>
<span class="sd">        this :class:`.Query` - if these do not correspond, unchecked errors</span>
<span class="sd">        will occur.</span>

<span class="sd">        The &#39;load&#39; argument is the same as that of :meth:`.Session.merge`.</span>

<span class="sd">        For an example of how :meth:`~.Query.merge_result` is used, see</span>
<span class="sd">        the source code for the example :ref:`examples_caching`, where</span>
<span class="sd">        :meth:`~.Query.merge_result` is used to efficiently restore state</span>
<span class="sd">        from a cache back into a target :class:`.Session`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">loading</span><span class="o">.</span><span class="n">merge_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">load</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s">&#39;limit&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span><span class="p">,</span>
            <span class="s">&#39;offset&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span>
            <span class="s">&#39;distinct&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">,</span>
            <span class="s">&#39;prefixes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefixes</span><span class="p">,</span>
            <span class="s">&#39;suffixes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffixes</span><span class="p">,</span>
            <span class="s">&#39;group_by&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">or</span> <span class="bp">None</span><span class="p">,</span>
            <span class="s">&#39;having&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_having</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_should_nest_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_args</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;limit&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;offset&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;distinct&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A convenience method that turns a query into an EXISTS subquery</span>
<span class="sd">        of the form EXISTS (SELECT 1 FROM ... WHERE ...).</span>

<span class="sd">        e.g.::</span>

<span class="sd">            q = session.query(User).filter(User.name == &#39;fred&#39;)</span>
<span class="sd">            session.query(q.exists())</span>

<span class="sd">        Producing SQL similar to::</span>

<span class="sd">            SELECT EXISTS (</span>
<span class="sd">                SELECT 1 FROM users WHERE users.name = :name_1</span>
<span class="sd">            ) AS anon_1</span>

<span class="sd">        The EXISTS construct is usually used in the WHERE clause::</span>

<span class="sd">            session.query(User.id).filter(q.exists()).scalar()</span>

<span class="sd">        Note that some databases such as SQL Server don&#39;t allow an</span>
<span class="sd">        EXISTS expression to be present in the columns clause of a</span>
<span class="sd">        SELECT.    To select a simple boolean value based on the exists</span>
<span class="sd">        as a WHERE, use :func:`.literal`::</span>

<span class="sd">            from sqlalchemy import literal</span>

<span class="sd">            session.query(literal(True)).filter(q.exists()).scalar()</span>

<span class="sd">        .. versionadded:: 0.8.1</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># .add_columns() for the case that we are a query().select_from(X),</span>
        <span class="c"># so that &quot;.statement&quot; can be produced (#2995) but also without</span>
        <span class="c"># omitting the FROM clause from a query(X) (#2818);</span>
        <span class="c"># .with_only_columns() after we have a core select() so that</span>
        <span class="c"># we get just &quot;SELECT 1&quot; without any entities.</span>
        <span class="k">return</span> <span class="n">sql</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span><span class="o">.</span>
                          <span class="n">statement</span><span class="o">.</span><span class="n">with_only_columns</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a count of rows this Query would return.</span>

<span class="sd">        This generates the SQL for this Query as follows::</span>

<span class="sd">            SELECT count(1) AS count_1 FROM (</span>
<span class="sd">                SELECT &lt;rest of query follows...&gt;</span>
<span class="sd">            ) AS anon_1</span>

<span class="sd">        .. versionchanged:: 0.7</span>
<span class="sd">            The above scheme is newly refined as of 0.7b3.</span>

<span class="sd">        For fine grained control over specific columns</span>
<span class="sd">        to count, to skip the usage of a subquery or</span>
<span class="sd">        otherwise control of the FROM clause,</span>
<span class="sd">        or to use other aggregate functions,</span>
<span class="sd">        use :attr:`~sqlalchemy.sql.expression.func`</span>
<span class="sd">        expressions in conjunction</span>
<span class="sd">        with :meth:`~.Session.query`, i.e.::</span>

<span class="sd">            from sqlalchemy import func</span>

<span class="sd">            # count User records, without</span>
<span class="sd">            # using a subquery.</span>
<span class="sd">            session.query(func.count(User.id))</span>

<span class="sd">            # return count of user &quot;id&quot; grouped</span>
<span class="sd">            # by &quot;name&quot;</span>
<span class="sd">            session.query(func.count(User.id)).\\</span>
<span class="sd">                    group_by(User.name)</span>

<span class="sd">            from sqlalchemy import distinct</span>

<span class="sd">            # count distinct &quot;name&quot; values</span>
<span class="sd">            session.query(func.count(distinct(User.name)))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">sql</span><span class="o">.</span><span class="n">literal_column</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_self</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s">&#39;evaluate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk delete query.</span>

<span class="sd">        Deletes rows matched by this query from the database.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\\</span>
<span class="sd">                delete(synchronize_session=False)</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\\</span>
<span class="sd">                delete(synchronize_session=&#39;evaluate&#39;)</span>

<span class="sd">        .. warning:: The :meth:`.Query.delete` method is a &quot;bulk&quot; operation,</span>
<span class="sd">           which bypasses ORM unit-of-work automation in favor of greater</span>
<span class="sd">           performance.  **Please read all caveats and warnings below.**</span>

<span class="sd">        :param synchronize_session: chooses the strategy for the removal of</span>
<span class="sd">            matched objects from the session. Valid values are:</span>

<span class="sd">            ``False`` - don&#39;t synchronize the session. This option is the most</span>
<span class="sd">            efficient and is reliable once the session is expired, which</span>
<span class="sd">            typically occurs after a commit(), or explicitly using</span>
<span class="sd">            expire_all(). Before the expiration, objects may still remain in</span>
<span class="sd">            the session which were in fact deleted which can lead to confusing</span>
<span class="sd">            results if they are accessed via get() or already loaded</span>
<span class="sd">            collections.</span>

<span class="sd">            ``&#39;fetch&#39;`` - performs a select query before the delete to find</span>
<span class="sd">            objects that are matched by the delete query and need to be</span>
<span class="sd">            removed from the session. Matched objects are removed from the</span>
<span class="sd">            session.</span>

<span class="sd">            ``&#39;evaluate&#39;`` - Evaluate the query&#39;s criteria in Python straight</span>
<span class="sd">            on the objects in the session. If evaluation of the criteria isn&#39;t</span>
<span class="sd">            implemented, an error is raised.</span>

<span class="sd">            The expression evaluator currently doesn&#39;t account for differing</span>
<span class="sd">            string collations between the database and Python.</span>

<span class="sd">        :return: the count of rows matched as returned by the database&#39;s</span>
<span class="sd">          &quot;row count&quot; feature.</span>

<span class="sd">        .. warning:: **Additional Caveats for bulk query deletes**</span>

<span class="sd">            * The method does **not** offer in-Python cascading of</span>
<span class="sd">              relationships - it is assumed that ON DELETE CASCADE/SET</span>
<span class="sd">              NULL/etc. is configured for any foreign key references</span>
<span class="sd">              which require it, otherwise the database may emit an</span>
<span class="sd">              integrity violation if foreign key references are being</span>
<span class="sd">              enforced.</span>

<span class="sd">              After the DELETE, dependent objects in the</span>
<span class="sd">              :class:`.Session` which were impacted by an ON DELETE</span>
<span class="sd">              may not contain the current state, or may have been</span>
<span class="sd">              deleted. This issue is resolved once the</span>
<span class="sd">              :class:`.Session` is expired, which normally occurs upon</span>
<span class="sd">              :meth:`.Session.commit` or can be forced by using</span>
<span class="sd">              :meth:`.Session.expire_all`.  Accessing an expired</span>
<span class="sd">              object whose row has been deleted will invoke a SELECT</span>
<span class="sd">              to locate the row; when the row is not found, an</span>
<span class="sd">              :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is</span>
<span class="sd">              raised.</span>

<span class="sd">            * The ``&#39;fetch&#39;`` strategy results in an additional</span>
<span class="sd">              SELECT statement emitted and will significantly reduce</span>
<span class="sd">              performance.</span>

<span class="sd">            * The ``&#39;evaluate&#39;`` strategy performs a scan of</span>
<span class="sd">              all matching objects within the :class:`.Session`; if the</span>
<span class="sd">              contents of the :class:`.Session` are expired, such as</span>
<span class="sd">              via a proceeding :meth:`.Session.commit` call, **this will</span>
<span class="sd">              result in SELECT queries emitted for every matching object**.</span>

<span class="sd">            * The :meth:`.MapperEvents.before_delete` and</span>
<span class="sd">              :meth:`.MapperEvents.after_delete`</span>
<span class="sd">              events **are not invoked** from this method.  Instead, the</span>
<span class="sd">              :meth:`.SessionEvents.after_bulk_delete` method is provided to</span>
<span class="sd">              act upon a mass DELETE of entity rows.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.update`</span>

<span class="sd">            :ref:`inserts_and_updates` - Core SQL tutorial</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: cascades need handling.</span>

        <span class="n">delete_op</span> <span class="o">=</span> <span class="n">persistence</span><span class="o">.</span><span class="n">BulkDelete</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="p">)</span>
        <span class="n">delete_op</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">delete_op</span><span class="o">.</span><span class="n">rowcount</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s">&#39;evaluate&#39;</span><span class="p">,</span> <span class="n">update_args</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk update query.</span>

<span class="sd">        Updates rows matched by this query in the database.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\\</span>
<span class="sd">                update({User.age: User.age - 10}, synchronize_session=False)</span>

<span class="sd">            sess.query(User).filter(User.age == 25).\\</span>
<span class="sd">                update({&quot;age&quot;: User.age - 10}, synchronize_session=&#39;evaluate&#39;)</span>


<span class="sd">        .. warning:: The :meth:`.Query.update` method is a &quot;bulk&quot; operation,</span>
<span class="sd">           which bypasses ORM unit-of-work automation in favor of greater</span>
<span class="sd">           performance.  **Please read all caveats and warnings below.**</span>


<span class="sd">        :param values: a dictionary with attributes names, or alternatively</span>
<span class="sd">         mapped attributes or SQL expressions, as keys, and literal</span>
<span class="sd">         values or sql expressions as values.</span>

<span class="sd">          .. versionchanged:: 1.0.0 - string names in the values dictionary</span>
<span class="sd">             are now resolved against the mapped entity; previously, these</span>
<span class="sd">             strings were passed as literal column names with no mapper-level</span>
<span class="sd">             translation.</span>

<span class="sd">        :param synchronize_session: chooses the strategy to update the</span>
<span class="sd">         attributes on objects in the session. Valid values are:</span>

<span class="sd">            ``False`` - don&#39;t synchronize the session. This option is the most</span>
<span class="sd">            efficient and is reliable once the session is expired, which</span>
<span class="sd">            typically occurs after a commit(), or explicitly using</span>
<span class="sd">            expire_all(). Before the expiration, updated objects may still</span>
<span class="sd">            remain in the session with stale values on their attributes, which</span>
<span class="sd">            can lead to confusing results.</span>

<span class="sd">            ``&#39;fetch&#39;`` - performs a select query before the update to find</span>
<span class="sd">            objects that are matched by the update query. The updated</span>
<span class="sd">            attributes are expired on matched objects.</span>

<span class="sd">            ``&#39;evaluate&#39;`` - Evaluate the Query&#39;s criteria in Python straight</span>
<span class="sd">            on the objects in the session. If evaluation of the criteria isn&#39;t</span>
<span class="sd">            implemented, an exception is raised.</span>

<span class="sd">            The expression evaluator currently doesn&#39;t account for differing</span>
<span class="sd">            string collations between the database and Python.</span>

<span class="sd">        :param update_args: Optional dictionary, if present will be passed</span>
<span class="sd">         to the underlying :func:`.update` construct as the ``**kw`` for</span>
<span class="sd">         the object.  May be used to pass dialect-specific arguments such</span>
<span class="sd">         as ``mysql_limit``.</span>

<span class="sd">         .. versionadded:: 1.0.0</span>

<span class="sd">        :return: the count of rows matched as returned by the database&#39;s</span>
<span class="sd">         &quot;row count&quot; feature.</span>

<span class="sd">        .. warning:: **Additional Caveats for bulk query updates**</span>

<span class="sd">            * The method does **not** offer in-Python cascading of</span>
<span class="sd">              relationships - it is assumed that ON UPDATE CASCADE is</span>
<span class="sd">              configured for any foreign key references which require</span>
<span class="sd">              it, otherwise the database may emit an integrity</span>
<span class="sd">              violation if foreign key references are being enforced.</span>

<span class="sd">              After the UPDATE, dependent objects in the</span>
<span class="sd">              :class:`.Session` which were impacted by an ON UPDATE</span>
<span class="sd">              CASCADE may not contain the current state; this issue is</span>
<span class="sd">              resolved once the :class:`.Session` is expired, which</span>
<span class="sd">              normally occurs upon :meth:`.Session.commit` or can be</span>
<span class="sd">              forced by using :meth:`.Session.expire_all`.</span>

<span class="sd">            * The ``&#39;fetch&#39;`` strategy results in an additional</span>
<span class="sd">              SELECT statement emitted and will significantly reduce</span>
<span class="sd">              performance.</span>

<span class="sd">            * The ``&#39;evaluate&#39;`` strategy performs a scan of</span>
<span class="sd">              all matching objects within the :class:`.Session`; if the</span>
<span class="sd">              contents of the :class:`.Session` are expired, such as</span>
<span class="sd">              via a proceeding :meth:`.Session.commit` call, **this will</span>
<span class="sd">              result in SELECT queries emitted for every matching object**.</span>

<span class="sd">            * The method supports multiple table updates, as detailed</span>
<span class="sd">              in :ref:`multi_table_updates`, and this behavior does</span>
<span class="sd">              extend to support updates of joined-inheritance and</span>
<span class="sd">              other multiple table mappings.  However, the **join</span>
<span class="sd">              condition of an inheritance mapper is not</span>
<span class="sd">              automatically rendered**. Care must be taken in any</span>
<span class="sd">              multiple-table update to explicitly include the joining</span>
<span class="sd">              condition between those tables, even in mappings where</span>
<span class="sd">              this is normally automatic. E.g. if a class ``Engineer``</span>
<span class="sd">              subclasses ``Employee``, an UPDATE of the ``Engineer``</span>
<span class="sd">              local table using criteria against the ``Employee``</span>
<span class="sd">              local table might look like::</span>

<span class="sd">                    session.query(Engineer).\\</span>
<span class="sd">                        filter(Engineer.id == Employee.id).\\</span>
<span class="sd">                        filter(Employee.name == &#39;dilbert&#39;).\\</span>
<span class="sd">                        update({&quot;engineer_type&quot;: &quot;programmer&quot;})</span>

<span class="sd">            * The :meth:`.MapperEvents.before_update` and</span>
<span class="sd">              :meth:`.MapperEvents.after_update`</span>
<span class="sd">              events **are not invoked from this method**.  Instead, the</span>
<span class="sd">              :meth:`.SessionEvents.after_bulk_update` method is provided to</span>
<span class="sd">              act upon a mass UPDATE of entity rows.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Query.delete`</span>

<span class="sd">            :ref:`inserts_and_updates` - Core SQL tutorial</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">update_args</span> <span class="o">=</span> <span class="n">update_args</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">update_op</span> <span class="o">=</span> <span class="n">persistence</span><span class="o">.</span><span class="n">BulkUpdate</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">synchronize_session</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">update_args</span><span class="p">)</span>
        <span class="n">update_op</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">update_op</span><span class="o">.</span><span class="n">rowcount</span>

    <span class="k">def</span> <span class="nf">_compile_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_compile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_compile</span><span class="p">:</span>
                <span class="n">new_query</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span> <span class="o">=</span> <span class="n">new_query</span>

        <span class="n">context</span> <span class="o">=</span> <span class="n">QueryContext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">context</span>

        <span class="n">context</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>

        <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">entity</span><span class="o">.</span><span class="n">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">create_eager_joins</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">strategy</span><span class="p">(</span><span class="o">*</span><span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">from_clause</span><span class="p">:</span>
            <span class="c"># &quot;load from explicit FROMs&quot; mode,</span>
            <span class="c"># i.e. when select_from() or join() is used</span>
            <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">from_clause</span><span class="p">)</span>
        <span class="c"># else &quot;load from discrete FROMs&quot; mode,</span>
        <span class="c"># i.e. when each _MappedEntity has its own FROM</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_single_crit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_for_single_inheritance</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_load_props</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s">&quot;No column-based properties specified for &quot;</span>
                    <span class="s">&quot;refresh operation. Use session.expire() &quot;</span>
                    <span class="s">&quot;to reload collections and related items.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s">&quot;Query contains no columns with which to &quot;</span>
                    <span class="s">&quot;SELECT from.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">multi_row_eager_loaders</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_nest_selectable</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_eager_statement</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_statement</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">_compound_eager_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c"># for eager joins present and LIMIT/OFFSET/DISTINCT,</span>
        <span class="c"># wrap the query inside a select,</span>
        <span class="c"># then append eager joins onto that</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">order_by_col_expr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                    <span class="n">sql_util</span><span class="o">.</span><span class="n">unwrap_order_by</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span>
                <span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">order_by_col_expr</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">+</span> <span class="n">order_by_col_expr</span><span class="p">,</span>
            <span class="n">context</span><span class="o">.</span><span class="n">whereclause</span><span class="p">,</span>
            <span class="n">from_obj</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">froms</span><span class="p">,</span>
            <span class="n">use_labels</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
            <span class="c"># TODO: this order_by is only needed if</span>
            <span class="c"># LIMIT/OFFSET is present in self._select_args,</span>
            <span class="c"># else the application on the outside is enough</span>
            <span class="n">order_by</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_select_args</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_hints</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="o">*</span><span class="n">hint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

        <span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_equivs</span><span class="p">()</span>

        <span class="n">context</span><span class="o">.</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="n">equivs</span><span class="p">)</span>

        <span class="n">statement</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inner</span><span class="p">]</span> <span class="o">+</span> <span class="n">context</span><span class="o">.</span><span class="n">secondary_columns</span><span class="p">,</span>
            <span class="n">use_labels</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

        <span class="n">statement</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="n">from_clause</span> <span class="o">=</span> <span class="n">inner</span>
        <span class="k">for</span> <span class="n">eager_join</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">eager_joins</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c"># EagerLoader places a &#39;stop_on&#39; attribute on the join,</span>
            <span class="c"># giving us a marker as to where the &quot;splice point&quot; of</span>
            <span class="c"># the join should be</span>
            <span class="n">from_clause</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">splice_joins</span><span class="p">(</span>
                <span class="n">from_clause</span><span class="p">,</span>
                <span class="n">eager_join</span><span class="p">,</span> <span class="n">eager_join</span><span class="o">.</span><span class="n">stop_on</span><span class="p">)</span>

        <span class="n">statement</span><span class="o">.</span><span class="n">append_from</span><span class="p">(</span><span class="n">from_clause</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span>
                <span class="o">*</span><span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="o">.</span><span class="n">copy_and_process</span><span class="p">(</span>
                    <span class="n">context</span><span class="o">.</span><span class="n">order_by</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">statement</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="o">.</span><span class="n">eager_order_by</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">statement</span>

    <span class="k">def</span> <span class="nf">_simple_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">order_by_col_expr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                    <span class="n">sql_util</span><span class="o">.</span><span class="n">unwrap_order_by</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span>
                <span class="p">])</span>
            <span class="p">)</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">+=</span> <span class="n">order_by_col_expr</span>

        <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">eager_joins</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">statement</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">+</span>
            <span class="n">context</span><span class="o">.</span><span class="n">secondary_columns</span><span class="p">,</span>
            <span class="n">context</span><span class="o">.</span><span class="n">whereclause</span><span class="p">,</span>
            <span class="n">from_obj</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">froms</span><span class="p">,</span>
            <span class="n">use_labels</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">order_by</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_select_args</span>
        <span class="p">)</span>
        <span class="n">statement</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_for_update_arg</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_hints</span><span class="p">:</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="n">with_hint</span><span class="p">(</span><span class="o">*</span><span class="n">hint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">:</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">eager_order_by</span><span class="p">:</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">append_order_by</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="o">.</span><span class="n">eager_order_by</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">statement</span>

    <span class="k">def</span> <span class="nf">_adjust_for_single_inheritance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply single-table-inheritance filtering.</span>

<span class="sd">        For all distinct single-table-inheritance mappers represented in</span>
<span class="sd">        the columns clause of this query, add criterion to the WHERE</span>
<span class="sd">        clause of the given QueryContext such that only the appropriate</span>
<span class="sd">        subtypes are selected from the total results.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">ext_info</span><span class="p">,</span> <span class="n">adapter</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mapper_adapter_map</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">ext_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_entities</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">single_crit</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_single_table_criterion</span>
            <span class="k">if</span> <span class="n">single_crit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">adapter</span><span class="p">:</span>
                    <span class="n">single_crit</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">single_crit</span><span class="p">)</span>
                <span class="n">single_crit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="n">single_crit</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                <span class="n">context</span><span class="o">.</span><span class="n">whereclause</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span>
                    <span class="n">sql</span><span class="o">.</span><span class="n">True_</span><span class="o">.</span><span class="n">_ifnone</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">whereclause</span><span class="p">),</span>
                    <span class="n">single_crit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compile_context</span><span class="p">()</span><span class="o">.</span><span class="n">statement</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..sql.selectable</span> <span class="kn">import</span> <span class="n">ForUpdateArg</span>


<span class="k">class</span> <span class="nc">LockmodeArg</span><span class="p">(</span><span class="n">ForUpdateArg</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_legacy_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&quot;read&quot;</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">nowait</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&quot;update&quot;</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="n">nowait</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&quot;update_nowait&quot;</span><span class="p">:</span>
            <span class="n">nowait</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">read</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s">&quot;Unknown with_lockmode argument: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">LockmodeArg</span><span class="p">(</span><span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="n">nowait</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_QueryEntity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;represent an entity column returned within a Query result.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span> <span class="ow">is</span> <span class="n">_QueryEntity</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">_is_mapped_class</span><span class="p">(</span><span class="n">entity</span><span class="p">):</span>
                <span class="n">cls</span> <span class="o">=</span> <span class="n">_MapperEntity</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">):</span>
                <span class="n">cls</span> <span class="o">=</span> <span class="n">_BundleEntity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls</span> <span class="o">=</span> <span class="n">_ColumnEntity</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span>


<span class="k">class</span> <span class="nc">_MapperEntity</span><span class="p">(</span><span class="n">_QueryEntity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;mapper/class/AliasedClass entity&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query</span><span class="o">.</span><span class="n">_primary_entity</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">_primary_entity</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">entity</span>

    <span class="n">supports_single_entity</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">setup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">mapper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aliased_adapter</span> <span class="o">=</span> <span class="n">aliased_adapter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">with_polymorphic_mappers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span> <span class="o">=</span> \
            <span class="n">ext_info</span><span class="o">.</span><span class="n">polymorphic_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="n">ext_info</span>
        <span class="k">if</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="n">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">_path_registry</span>

    <span class="k">def</span> <span class="nf">set_with_polymorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">cls_or_mappers</span><span class="p">,</span>
                             <span class="n">selectable</span><span class="p">,</span> <span class="n">polymorphic_on</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Receive an update from a call to query.with_polymorphic().</span>

<span class="sd">        Note the newer style of using a free standing with_polymporphic()</span>
<span class="sd">        construct doesn&#39;t make use of this method.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="c"># TODO: invalidrequest ?</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s">&quot;Can&#39;t use with_polymorphic() against &quot;</span>
                <span class="s">&quot;an Aliased object&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">cls_or_mappers</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">_reset_polymorphic_adapter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">mappers</span><span class="p">,</span> <span class="n">from_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_with_polymorphic_args</span><span class="p">(</span>
            <span class="n">cls_or_mappers</span><span class="p">,</span> <span class="n">selectable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span> <span class="o">=</span> <span class="n">mappers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span> <span class="o">=</span> <span class="n">polymorphic_on</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span> <span class="o">=</span> <span class="n">from_obj</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_mapper_loads_polymorphically_with</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                <span class="n">from_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span><span class="p">))</span>

    <span class="n">filter_fn</span> <span class="o">=</span> <span class="nb">id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero_or_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>

    <span class="k">def</span> <span class="nf">corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">entity</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entity</span><span class="o">.</span><span class="n">_base_alias</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">_base_alias</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="o">.</span><span class="n">_use_mapper_path</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">entity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">entity</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>

        <span class="k">return</span> <span class="n">entity</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_entity_clauses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>

        <span class="n">adapter</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_aliased_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="p">:</span>
                <span class="n">adapter</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_polymorphic_adapters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliased_adapter</span>

        <span class="k">if</span> <span class="n">adapter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">adapter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entity_clauses</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span> <span class="ow">and</span> <span class="n">adapter</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">adapter</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span>

        <span class="c"># polymorphic mappers which have concrete tables in</span>
        <span class="c"># their hierarchy usually</span>
        <span class="c"># require row aliasing unconditionally.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adapter</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_requires_row_aliasing</span><span class="p">:</span>
            <span class="n">adapter</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_equivalent_columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_primary_entity</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">only_load_props</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_only_load_props</span>
            <span class="n">refresh_state</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">refresh_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">only_load_props</span> <span class="o">=</span> <span class="n">refresh_state</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">_instance</span> <span class="o">=</span> <span class="n">loading</span><span class="o">.</span><span class="n">_instance_processor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span>
            <span class="n">context</span><span class="p">,</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">adapter</span><span class="p">,</span>
            <span class="n">only_load_props</span><span class="o">=</span><span class="n">only_load_props</span><span class="p">,</span>
            <span class="n">refresh_state</span><span class="o">=</span><span class="n">refresh_state</span><span class="p">,</span>
            <span class="n">polymorphic_discriminator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">_instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>

    <span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entity_clauses</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="c"># if self._adapted_selectable is None:</span>
        <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selectable</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">order_by</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">order_by</span>

            <span class="c"># apply adaptation to the mapper&#39;s order_by if needed.</span>
            <span class="k">if</span> <span class="n">adapter</span><span class="p">:</span>
                <span class="n">context</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">adapt_list</span><span class="p">(</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span>
                        <span class="n">context</span><span class="o">.</span><span class="n">order_by</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">loading</span><span class="o">.</span><span class="n">_setup_entity_query</span><span class="p">(</span>
            <span class="n">context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="p">,</span>
            <span class="n">with_polymorphic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_with_polymorphic</span><span class="p">,</span>
            <span class="n">only_load_props</span><span class="o">=</span><span class="n">query</span><span class="o">.</span><span class="n">_only_load_props</span><span class="p">,</span>
            <span class="n">polymorphic_discriminator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_polymorphic_discriminator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>


<span class="nd">@inspection._self_inspects</span>
<span class="k">class</span> <span class="nc">Bundle</span><span class="p">(</span><span class="n">InspectionAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A grouping of SQL expressions that are returned by a :class:`.Query`</span>
<span class="sd">    under one namespace.</span>

<span class="sd">    The :class:`.Bundle` essentially allows nesting of the tuple-based</span>
<span class="sd">    results returned by a column-oriented :class:`.Query` object.  It also</span>
<span class="sd">    is extensible via simple subclassing, where the primary capability</span>
<span class="sd">    to override is that of how the set of expressions should be returned,</span>
<span class="sd">    allowing post-processing as well as custom return types, without</span>
<span class="sd">    involving ORM identity-mapped classes.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`bundles`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">single_entity</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;If True, queries for a single Bundle will be returned as a single</span>
<span class="sd">    entity, rather than an element within a keyed tuple.&quot;&quot;&quot;</span>

    <span class="n">is_clause_element</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">is_mapper</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">is_aliased_class</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">exprs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new :class:`.Bundle`.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            bn = Bundle(&quot;mybundle&quot;, MyClass.x, MyClass.y)</span>

<span class="sd">            for row in session.query(bn).filter(</span>
<span class="sd">                    bn.c.x == 5).filter(bn.c.y == 4):</span>
<span class="sd">                print(row.mybundle.x, row.mybundle.y)</span>

<span class="sd">        :param name: name of the bundle.</span>
<span class="sd">        :param \*exprs: columns or SQL expressions comprising the bundle.</span>
<span class="sd">        :param single_entity=False: if True, rows for this :class:`.Bundle`</span>
<span class="sd">         can be returned as a &quot;single entity&quot; outside of any enclosing tuple</span>
<span class="sd">         in the same manner as a mapped entity.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="n">exprs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">ColumnCollection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s">&quot;key&quot;</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">_label</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_entity</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;single_entity&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_entity</span><span class="p">)</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;A namespace of SQL expressions referred to by this :class:`.Bundle`.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            bn = Bundle(&quot;mybundle&quot;, MyClass.x, MyClass.y)</span>

<span class="sd">            q = sess.query(bn).filter(bn.c.x == 5)</span>

<span class="sd">        Nesting of bundles is also supported::</span>

<span class="sd">            b1 = Bundle(&quot;b1&quot;,</span>
<span class="sd">                    Bundle(&#39;b2&#39;, MyClass.a, MyClass.b),</span>
<span class="sd">                    Bundle(&#39;b3&#39;, MyClass.x, MyClass.y)</span>
<span class="sd">                )</span>

<span class="sd">            q = sess.query(b1).filter(</span>
<span class="sd">                b1.c.b2.c.a == 5).filter(b1.c.b3.c.y == 9)</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :attr:`.Bundle.c`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;An alias for :attr:`.Bundle.columns`.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">__clause_element__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expression</span><span class="o">.</span><span class="n">ClauseList</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">clauses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span><span class="o">.</span><span class="n">clauses</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide a copy of this :class:`.Bundle` passing a new label.&quot;&quot;&quot;</span>

        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">create_row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">procs</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce the &quot;row processing&quot; function for this :class:`.Bundle`.</span>

<span class="sd">        May be overridden by subclasses.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bundles` - includes an example of subclassing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keyed_tuple</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">lightweight_named_tuple</span><span class="p">(</span><span class="s">&#39;result&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">proc</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">keyed_tuple</span><span class="p">([</span><span class="n">proc</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">procs</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">proc</span>


<span class="k">class</span> <span class="nc">_BundleEntity</span><span class="p">(</span><span class="n">_QueryEntity</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">setup_entities</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">bundle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="n">bundle</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">setup_entities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">bundle</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">):</span>
                    <span class="n">_BundleEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_ColumnEntity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">supports_single_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span><span class="o">.</span><span class="n">single_entity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ezero</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero</span>
            <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ezero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="c"># TODO: this seems to have no effect for</span>
        <span class="c"># _ColumnEntity either</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero_or_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ezero</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">entity_zero_or_selectable</span>
            <span class="k">if</span> <span class="n">ezero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ezero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_BundleEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span><span class="p">,</span> <span class="n">setup_entities</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c"># c._label_name = self._label_name</span>
        <span class="c"># c.entity_zero = self.entity_zero</span>
        <span class="c"># c.entities = self.entities</span>

        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ent</span><span class="o">.</span><span class="n">adapt_to_selectable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ent</span><span class="o">.</span><span class="n">setup_entity</span><span class="p">(</span><span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">:</span>
            <span class="n">ent</span><span class="o">.</span><span class="n">setup_context</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">procs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">row_processor</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entities</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bundle</span><span class="o">.</span><span class="n">create_row_processor</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">procs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">proc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>


<span class="k">class</span> <span class="nc">_ColumnEntity</span><span class="p">(</span><span class="n">_QueryEntity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Column/expression based entity.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="n">search_entities</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">check_column</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">literal_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">name</span>
            <span class="n">search_entities</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">check_column</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">_entity</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="p">(</span>
            <span class="n">attributes</span><span class="o">.</span><span class="n">QueryableAttribute</span><span class="p">,</span>
            <span class="n">interfaces</span><span class="o">.</span><span class="n">PropComparator</span>
        <span class="p">)):</span>
            <span class="n">_entity</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s">&#39;_parententity&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_entity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">search_entities</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">key</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">_query_clause_element</span><span class="p">()</span>
            <span class="n">check_column</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">Bundle</span><span class="p">):</span>
                <span class="n">_BundleEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">sql</span><span class="o">.</span><span class="n">ColumnElement</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s">&#39;_select_iterable&#39;</span><span class="p">):</span>
                <span class="c"># break out an object like Table into</span>
                <span class="c"># individual columns</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">_select_iterable</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">column</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">_ColumnEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">column</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span>

            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s">&quot;SQL expression, column, or mapped entity &quot;</span>
                <span class="s">&quot;expected - got &#39;</span><span class="si">%r</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">check_column</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s">&#39;key&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">search_entities</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">type</span>
        <span class="k">if</span> <span class="n">type_</span><span class="o">.</span><span class="n">hashable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">counter</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">counter</span><span class="p">()</span>

        <span class="c"># If the Column is unnamed, give it a</span>
        <span class="c"># label() so that mutable column expressions</span>
        <span class="c"># can be located in the result even</span>
        <span class="c"># if the expression&#39;s identity has been changed</span>
        <span class="c"># due to adaption.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">column</span><span class="o">.</span><span class="n">_label</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s">&#39;is_literal&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span><span class="p">)</span>

        <span class="n">query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">froms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c"># look for ORM entities represented within the</span>
        <span class="c"># given expression.  Try to count only entities</span>
        <span class="c"># for columns whose FROM object is in the actual list</span>
        <span class="c"># of FROMs for the overall expression - this helps</span>
        <span class="c"># subqueries which were built from ORM constructs from</span>
        <span class="c"># leaking out their entities into the main select construct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span> <span class="o">=</span> <span class="n">actual_froms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">_from_objects</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">search_entities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="n">_entity</span>
            <span class="k">if</span> <span class="n">_entity</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[</span><span class="n">_entity</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_entities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entities</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_elements</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">visitors</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="p">{})</span>
                <span class="k">if</span> <span class="s">&#39;parententity&#39;</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
            <span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_list</span><span class="p">([</span>
                <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="s">&#39;parententity&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">all_elements</span>
                <span class="k">if</span> <span class="s">&#39;parententity&#39;</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
            <span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_from_entities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
                <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span><span class="p">[</span><span class="s">&#39;parententity&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">all_elements</span>
                <span class="k">if</span> <span class="s">&#39;parententity&#39;</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">_annotations</span>
                <span class="ow">and</span> <span class="n">actual_froms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_from_objects</span><span class="p">)</span>
            <span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">supports_single_entity</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_zero_or_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">adapt_to_selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_ColumnEntity</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">corresponding_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>
        <span class="n">c</span><span class="o">.</span><span class="n">entity_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="n">c</span><span class="o">.</span><span class="n">entities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entities</span>

    <span class="k">def</span> <span class="nf">setup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_info</span><span class="p">,</span> <span class="n">aliased_adapter</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;selectable&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selectable</span> <span class="o">=</span> <span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_froms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span><span class="o">.</span><span class="n">_from_objects</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">froms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ext_info</span><span class="o">.</span><span class="n">selectable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">corresponds_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
        <span class="c"># TODO: just returning False here,</span>
        <span class="c"># no tests fail</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">_is_aliased_class</span><span class="p">(</span><span class="n">entity</span><span class="p">):</span>
            <span class="c"># TODO: polymorphic subclasses ?</span>
            <span class="k">return</span> <span class="n">entity</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">_is_aliased_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">entity</span><span class="o">.</span><span class="n">common_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_zero</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="s">&#39;fetch_column&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">attributes</span><span class="p">[(</span><span class="s">&#39;fetch_column&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">adapter</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>

        <span class="n">getter</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_getter</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">getter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label_name</span>

    <span class="k">def</span> <span class="nf">setup_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_adapt_clause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">froms</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">froms</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">primary_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="n">context</span><span class="o">.</span><span class="n">attributes</span><span class="p">[(</span><span class="s">&#39;fetch_column&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">column</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">QueryContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&#39;multi_row_eager_loaders&#39;</span><span class="p">,</span> <span class="s">&#39;adapter&#39;</span><span class="p">,</span> <span class="s">&#39;froms&#39;</span><span class="p">,</span> <span class="s">&#39;for_update&#39;</span><span class="p">,</span>
        <span class="s">&#39;query&#39;</span><span class="p">,</span> <span class="s">&#39;session&#39;</span><span class="p">,</span> <span class="s">&#39;autoflush&#39;</span><span class="p">,</span> <span class="s">&#39;populate_existing&#39;</span><span class="p">,</span>
        <span class="s">&#39;invoke_all_eagers&#39;</span><span class="p">,</span> <span class="s">&#39;version_check&#39;</span><span class="p">,</span> <span class="s">&#39;refresh_state&#39;</span><span class="p">,</span>
        <span class="s">&#39;primary_columns&#39;</span><span class="p">,</span> <span class="s">&#39;secondary_columns&#39;</span><span class="p">,</span> <span class="s">&#39;eager_order_by&#39;</span><span class="p">,</span>
        <span class="s">&#39;eager_joins&#39;</span><span class="p">,</span> <span class="s">&#39;create_eager_joins&#39;</span><span class="p">,</span> <span class="s">&#39;propagate_options&#39;</span><span class="p">,</span>
        <span class="s">&#39;attributes&#39;</span><span class="p">,</span> <span class="s">&#39;statement&#39;</span><span class="p">,</span> <span class="s">&#39;from_clause&#39;</span><span class="p">,</span> <span class="s">&#39;whereclause&#39;</span><span class="p">,</span>
        <span class="s">&#39;order_by&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;_for_update_arg&#39;</span><span class="p">,</span> <span class="s">&#39;runid&#39;</span><span class="p">,</span> <span class="s">&#39;partials&#39;</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">SelectBase</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="ow">not</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="o">.</span><span class="n">_textual</span> <span class="ow">and</span> \
                    <span class="ow">not</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="o">.</span><span class="n">use_labels</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span><span class="o">.</span><span class="n">apply_labels</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_statement</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_clause</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_from_obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whereclause</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_criterion</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_order_by</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multi_row_eager_loaders</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adapter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">froms</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">for_update</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populate_existing</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_populate_existing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke_all_eagers</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_invoke_all_eagers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version_check</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_version_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_state</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_refresh_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondary_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eager_order_by</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eager_joins</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_eager_joins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propagate_options</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">_with_options</span> <span class="k">if</span>
                                     <span class="n">o</span><span class="o">.</span><span class="n">propagate_to_loaders</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">AliasOption</span><span class="p">(</span><span class="n">interfaces</span><span class="o">.</span><span class="n">MapperOption</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.MapperOption` that will indicate to the :class:`.Query`</span>
<span class="sd">        that the main table has been aliased.</span>

<span class="sd">        This is a seldom-used option to suit the</span>
<span class="sd">        very rare case that :func:`.contains_eager`</span>
<span class="sd">        is being used in conjunction with a user-defined SELECT</span>
<span class="sd">        statement that aliases the parent table.  E.g.::</span>

<span class="sd">            # define an aliased UNION called &#39;ulist&#39;</span>
<span class="sd">            ulist = users.select(users.c.user_id==7).\\</span>
<span class="sd">                            union(users.select(users.c.user_id&gt;7)).\\</span>
<span class="sd">                            alias(&#39;ulist&#39;)</span>

<span class="sd">            # add on an eager load of &quot;addresses&quot;</span>
<span class="sd">            statement = ulist.outerjoin(addresses).\\</span>
<span class="sd">                            select().apply_labels()</span>

<span class="sd">            # create query, indicating &quot;ulist&quot; will be an</span>
<span class="sd">            # alias for the main table, &quot;addresses&quot;</span>
<span class="sd">            # property should be eager loaded</span>
<span class="sd">            query = session.query(User).options(</span>
<span class="sd">                                    contains_alias(ulist),</span>
<span class="sd">                                    contains_eager(User.addresses))</span>

<span class="sd">            # then get results via the statement</span>
<span class="sd">            results = query.from_statement(statement).all()</span>

<span class="sd">        :param alias: is the string name of an alias, or a</span>
<span class="sd">         :class:`~.sql.expression.Alias` object representing</span>
<span class="sd">         the alias.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">alias</span>

    <span class="k">def</span> <span class="nf">process_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">_mapper_zero</span><span class="p">()</span><span class="o">.</span><span class="n">mapped_table</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span>
        <span class="n">query</span><span class="o">.</span><span class="n">_from_obj_alias</span> <span class="o">=</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">ColumnAdapter</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Author.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>